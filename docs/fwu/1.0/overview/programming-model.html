<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="4. Programming model" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://arm-software.github.io/psa-api/fwu/1.0/overview/programming-model.html" />
<link rel="canonical" href="https://arm-software.github.io/psa-api/fwu/1.0/overview/programming-model.html" />
<meta property="og:site_name" content="PSA Certified Firmware Update API 1.0" />
<meta property="og:description" content="The firmware store: For each component, depending on the state or progress of a firmware update, there can be one or more firmware images currently in the component’s firmware store: An active imag..." />
<meta name="description" content="The firmware store: For each component, depending on the state or progress of a firmware update, there can be one or more firmware images currently in the component’s firmware store: An active imag..." />

    <title>4. Programming model &#8212; PSA Certified Firmware Update API 1.0</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="preconnect" type="text/css" href="https://fonts.googleapis.com" />
    <link rel="preconnect" type="text/css" href="https://fonts.gstatic.com" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,400;0,700;1,400&display=swap" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5. API reference" href="../api/api.html" />
    <link rel="prev" title="3. Architecture" href="architecture.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="programming-model">
<span id="id1"></span><h1><span class="section-number">4. </span>Programming model<a class="headerlink" href="#programming-model" title="Permalink to this heading">¶</a></h1>
<section id="the-firmware-store">
<span id="firmware-store"></span><h2><span class="section-number">4.1. </span>The firmware store<a class="headerlink" href="#the-firmware-store" title="Permalink to this heading">¶</a></h2>
<p>For each component, depending on the state or progress of a firmware update, there can be one or more firmware images currently in the component’s firmware store:</p>
<ul class="simple">
<li><p>An <em>active</em> image that is actively in use by the system.</p></li>
<li><p>A <em>staged</em> image that is being prepared for installation.</p></li>
<li><p>A <em>backup</em> of the previous image that is being replaced, used to recover if an attempted update fails.</p></li>
<li><p>A <em>dirty</em> image that can be erased.</p></li>
</ul>
<p>For a component that is essential for system operation, there will always be exactly one <em>active</em> image. Other images might, or might not, be present in the firmware store.</p>
<p>The Firmware Update API uses a state model for the firmware store that requires storage for a minimum of two images. This is possible because the store does not need to hold more than one <em>staged</em>, <em>backup</em>, or <em>dirty</em> image concurrently. An implementation of the Firmware Update API can have storage for more than two images, and selects the appropriate storage area for a requested operation. For example, providing additional image storage locations can reduce the need to carry out expensive erase operations on the storage during normal device operation.</p>
<p>This document uses the following names to identify the two required locations:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Location</p></th>
<th class="head"><p>Present</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>Active</em></p></td>
<td><p>Always</p></td>
<td><p>The image that is actively in use by the system</p></td>
</tr>
<tr class="row-odd"><td><p><em>Second</em></p></td>
<td><p>Sometimes</p></td>
<td><p>An image that is being prepared, or is kept for recovery, or needs to be erased</p></td>
</tr>
</tbody>
</table>
<p>Depending on the system and memory design, the <em>active</em> and <em>second</em> locations can be fixed physical storage locations, or can refer to different physical storage locations over time as an update progresses. The implementation of the Firmware Update API is responsible for mapping the logical storage locations to the stored firmware images.</p>
<p>During the course of an update, a specific firmware image can change from being <em>active</em> to <em>second</em>, or from <em>second</em> to <em>active</em>. For example:</p>
<ul class="simple">
<li><p>An image will switch from being <em>second</em> — while being prepared — to <em>active</em> following installation.</p></li>
<li><p>An image will switch from being <em>active</em> to <em>second</em> when it becomes the backup image during installation of new firmware.</p></li>
</ul>
</section>
<section id="state-model">
<span id="id2"></span><h2><span class="section-number">4.2. </span>State model<a class="headerlink" href="#state-model" title="Permalink to this heading">¶</a></h2>
<p>The full set of use cases for the Firmware Update API requires a fine-grained state model to track each component through the update process. See <a class="reference internal" href="#state-rationale"><span class="secref">Rationale</span></a> for an explanation of the relationship between state model features and use cases.</p>
<p>This section describes the complete state model. Some of the states and transitions in the state model are only necessary for specific use cases. In addition, the persistence of the component states following a reboot depends on the implementation capabilities.</p>
<p>The complete state model is applicable for components that have the following properties:</p>
<ol class="arabic simple">
<li><p>A reboot is required to complete installation of a new image.</p></li>
<li><p>The image must be tested prior to acceptance.</p></li>
<li><p>A candidate image is persistent across a reboot, before it is staged for installation.</p></li>
</ol>
<p>For components that do not require testing of new firmware before acceptance, or components that do not require a reboot to complete installation, only a subset of the states are visible to the update client. For components with <a class="reference internal" href="../about.html#term-volatile-staging"><span class="term">volatile staging</span></a>, almost all component states will transition when the system restarts. Some common examples of alternative component update characteristics are described in <a class="reference internal" href="../appendix/variations.html#variations"><span class="secref">Variation in system design parameters</span></a>, including the changes in the state model for such components.</p>
<section id="component-state">
<span id="id3"></span><h3><span class="section-number">4.2.1. </span>Component state<a class="headerlink" href="#component-state" title="Permalink to this heading">¶</a></h3>
<p><span><a class="reference internal" href="#tab-states"><span class="numref">Table 4</span></a></span> shows the possible update states for a component. The states have corresponding elements in the API, see <a class="reference internal" href="../api/api.html#component-states"><span class="secref">Component states</span></a>.</p>
<table class="colwidths-given longtable docutils align-default" id="tab-states">
<caption><span class="caption-number">Table 4 </span><span class="caption-text">Component states</span><a class="headerlink" href="#tab-states" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>State</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>READY</p></td>
<td><p>This is the normal state for the component. There is just one image, it is <em>active</em>, and is currently in use by the system.</p>
<p>The component is ready for a new firmware update to be started.</p>
</td>
</tr>
<tr class="row-odd"><td><p>WRITING</p></td>
<td><p>A new firmware image is being written to the staging area, in preparation for installation.</p>
<p>When writing is complete, the image becomes a CANDIDATE for installation.</p>
<p>This state is always volatile for components that have <a class="reference internal" href="../about.html#term-volatile-staging"><span class="term">volatile staging</span></a>. For other components, it is <a class="reference internal" href="../about.html#term-implementation-defined"><span class="scterm">implementation defined</span></a> whether this state is volatile.</p>
<p>When this state is volatile, the incomplete image is discarded at reboot.</p>
</td>
</tr>
<tr class="row-even"><td><p>CANDIDATE</p></td>
<td><p>Transfer of the new firmware image to the staging area is complete.</p>
<p>When all components that require update are in CANDIDATE state, they can be installed.</p>
<p>This state is always volatile for components that have volatile staging. For other components, it is always persistent.</p>
<p>When this state is volatile, the candidate image is discarded at reboot.</p>
</td>
</tr>
<tr class="row-odd"><td><p>STAGED</p></td>
<td><p>Installation of the candidate image has been requested, but the system must be restarted as the final update operation runs within the bootloader.</p>
<p>This state is always volatile.</p>
</td>
</tr>
<tr class="row-even"><td><p>TRIAL</p></td>
<td><p>Installation of the staged image has succeeded, and is now the <em>active</em> image running in ‘trial mode’. This state is always volatile, and requires the trial to be explicitly accepted to make the update permanent.</p>
<p>In this state, the previously installed <em>active</em> image is preserved as the <em>second</em> image. If the trial is explicitly rejected, or the system restarts without accepting the trial, the previously installed image is re-installed and the trial image is rejected.</p>
</td>
</tr>
<tr class="row-odd"><td><p>REJECTED</p></td>
<td><p>The <em>active</em> trial image has been rejected, but the system must be restarted so the bootloader can revert to the previous image, which was previously saved as the <em>second</em> image.</p>
<p>This state is always volatile.</p>
</td>
</tr>
<tr class="row-even"><td><p>FAILED</p></td>
<td><p>An update to a new image has been attempted, but has failed, or been cancelled for some reason. The failure reason is recorded in the firmware store.</p>
<p>The <em>second</em> image needs to be cleaned before another update can be attempted.</p>
<p>This state is always volatile for components that have volatile staging. For other components, it is <a class="reference internal" href="../about.html#term-implementation-defined"><span class="scterm">implementation defined</span></a> whether this state is volatile.</p>
<p>When this state is volatile, the <em>second</em> image is cleaned at reboot.</p>
</td>
</tr>
<tr class="row-odd"><td><p>UPDATED</p></td>
<td><p>The <em>active</em> trial image has been accepted.</p>
<p>The <em>second</em> image contains the now-expired previous firmware image, which needs to be cleaned before another update can be started.</p>
<p>This state is always volatile for components that have volatile staging. For other components, it is <a class="reference internal" href="../about.html#term-implementation-defined"><span class="scterm">implementation defined</span></a> whether this state is volatile.</p>
<p>When this state is volatile, the <em>second</em> image is cleaned at reboot.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition-implementation-note admonition">
<p class="admonition-title">Implementation note</p>
<p>An implementation can have additional internal states, provided that implementation-specific states are not visible to the caller of the Firmware Update API.</p>
</div>
</section>
<section id="volatile-states">
<span id="id4"></span><h3><span class="section-number">4.2.2. </span>Volatile states<a class="headerlink" href="#volatile-states" title="Permalink to this heading">¶</a></h3>
<p>A component state is ‘volatile’, if the state is not preserved when the system reboots.</p>
<p>States that are volatile are not optional for an implementation of the Firmware Update API. Until a device reboots, the update service must follow the state transitions and report the resulting states as shown in the state model appropriate for the component update characteristics.</p>
<ul class="simple">
<li><p>READY state is never volatile.</p></li>
<li><p>STAGED, TRIAL, and REJECTED states are always volatile.</p></li>
<li><p>If the component has <a class="reference internal" href="../about.html#term-volatile-staging"><span class="term">volatile staging</span></a>, then CANDIDATE, WRITING, FAILED, and UPDATED states are volatile.</p></li>
<li><p>If the component does not have volatile staging, then CANDIDATE state is non-volatile, and it is <a class="reference internal" href="../about.html#term-implementation-defined"><span class="scterm">implementation defined</span></a> whether WRITING, FAILED, or UPDATED states are volatile.</p></li>
</ul>
<p>In most cases, at reboot the implementation effectively implements one or more transitions to a final, non-volatile state. The exception is for a component that is STAGED, and enters TRIAL state following a successful installation at reboot.</p>
<p>The transitions for volatile states are described as part of the appropriate state models for different types of firmware component. See <a class="reference internal" href="../appendix/variations.html#variations"><span class="secref">Variation in system design parameters</span></a>.</p>
</section>
<section id="state-transitions">
<span id="id5"></span><h3><span class="section-number">4.2.3. </span>State transitions<a class="headerlink" href="#state-transitions" title="Permalink to this heading">¶</a></h3>
<p>The state transitions occur either as a result of an function call from the update client, when the bootloader carries out an installation operation, or transitions over reboot from a volatile state. The transitions that occur within the bootloader are determined by the state of the component, and do not depend on the reason for the restart.</p>
<p>Table <span><a class="reference internal" href="#tab-operations"><span class="numref">Table 5</span></a></span> shows the operations that the update client uses to trigger transitions in the state model. The operations have corresponding elements in the API, see <a class="reference internal" href="../api/api.html#api-functions"><span class="secref">Firmware installation</span></a>.</p>
<table class="colwidths-auto docutils align-right" id="tab-operations">
<caption><span class="caption-number">Table 5 </span><span class="caption-text">Operations on components</span><a class="headerlink" href="#tab-operations" title="Permalink to this table">¶</a></caption>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">start</span></code></p></td>
<td><p>Begin a firmware update operation</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">write</span></code></p></td>
<td><p>Write all, or part, of a firmware image</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">finish</span></code></p></td>
<td><p>Complete preparation of a candidate firmware image</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cancel</span></code></p></td>
<td><p>Abandon a firmware image that is being prepared</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">install</span></code></p></td>
<td><p>Start the installation of candidate firmware images</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">accept</span></code></p></td>
<td><p>Accept an installation that is being trialed</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">reject</span></code></p></td>
<td><p>Abandon an installation</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">clean</span></code></p></td>
<td><p>Erase firmware storage before starting a new update</p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">write</span></code>, and <code class="docutils literal notranslate"><span class="pre">finish</span></code> operations are used to prepare a new firmware image. The <code class="docutils literal notranslate"><span class="pre">cancel</span></code> and <code class="docutils literal notranslate"><span class="pre">clean</span></code> operations are used to clean up a component after a successful, failed, or abandoned update. It is an error to invoke these operations on a component that is not in a valid starting state for the operation.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">install</span></code>, <code class="docutils literal notranslate"><span class="pre">accept</span></code>, and <code class="docutils literal notranslate"><span class="pre">reject</span></code> operations apply to all components in the system, affecting any component in the required starting state for the transition. This allows an update client to update multiple components atomically, if directed by the firmware image manifests. Components that are not in a valid starting state for these operations are not affected by the operation.</p>
<p><span><a class="reference internal" href="#fig-states"><span class="numref">Figure 7</span></a></span> shows the typical flow through the component states.</p>
<figure class="align-default" id="fig-states">
<a class="reference internal image-reference" href="../_images/default.svg"><img alt="../_images/default.svg" height="625" src="../_images/default.svg" width="412" /></a>
<figcaption>
<p><span class="caption-number">Figure 7 </span><span class="caption-text">The standard component state model transitions</span><a class="headerlink" href="#fig-states" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Note, that the READY state at the end is distinct from the starting READY state — at the end the <em>active</em> firmware image is the updated version. The component is ready to start the process again from the beginning for the next update.</p>
<p>The behavior in error scenarios is not shown, except for the transitions over reboot where a failure can only be reported to the update client by changing the state of the component.</p>
</section>
<section id="behavior-on-error">
<span id="id6"></span><h3><span class="section-number">4.2.4. </span>Behavior on error<a class="headerlink" href="#behavior-on-error" title="Permalink to this heading">¶</a></h3>
<p>Many of the operations in the Firmware Update API modify the firmware store. These operations are not required to have atomic operation with respect to the firmware store — when a failure occurs during one of these operations, the firmware store can be left in a different state after the operation reports an error status.</p>
<p>The following behavior is required by every implementation:</p>
<ul class="simple">
<li><p>When an operation returns the status <code class="docutils literal notranslate"><span class="pre">PSA_SUCCESS</span></code>, the requested action has been carried out.</p></li>
<li><p>When a operation returns the status <a class="reference internal" href="../api/api.html#c.PSA_SUCCESS_RESTART" title="PSA_SUCCESS_RESTART"><code class="docutils literal notranslate"><span class="pre">PSA_SUCCESS_RESTART</span></code></a>, or <a class="reference internal" href="../api/api.html#c.PSA_SUCCESS_REBOOT" title="PSA_SUCCESS_REBOOT"><code class="docutils literal notranslate"><span class="pre">PSA_SUCCESS_REBOOT</span></code></a>, the requested action has been carried out, and appropriate action must be taken by the caller to continue the installation or rollback process.</p></li>
<li><p>When a operation returns the status <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_BAD_STATE</span></code>, <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_DOES_NOT_EXIST</span></code>, or <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_NOT_SUPPORTED</span></code>, no action has been carried out, and the affected components’ states are unchanged.</p></li>
<li><p>If firmware image dependencies are verified when the component is in CANDIDATE state, a missing dependency leaves the component unchanged, in CANDIDATE state.</p></li>
<li><p>If there is a failure when verifying other manifest or firmware image properties of a component in WRITING, CANDIDATE or STAGED state, the component is transitioned to FAILED state.</p></li>
<li><p>If there is a failure when verifying or installing a new firmware image during a component restart, or system reboot, the component is transitioned to FAILED state.</p></li>
<li><p>A component always follows a transition that is shown in the appropriate state model, except for:</p>
<ul>
<li><p>If FAILED is a volatile state, a reboot transition that is shown to end in the FAILED state must include a <code class="docutils literal notranslate"><span class="pre">clean</span></code> operation to end in READY state.</p></li>
<li><p>Other transitions to FAILED state, as described in the preceding rules.</p></li>
<li><p>If UPDATED is a volatile state, a reboot transition that is shown to end in the UPDATED state must include a <code class="docutils literal notranslate"><span class="pre">clean</span></code> operation to end in READY state.</p></li>
</ul>
</li>
</ul>
<p>If an operation fails because of other conditions, it is <a class="reference internal" href="../about.html#term-implementation-defined"><span class="scterm">implementation defined</span></a> whether the component state is unchanged, or is transitioned to FAILED state. In this situation, it is recommended that the update client abort the update process with a <code class="docutils literal notranslate"><span class="pre">cancel</span></code> operation.</p>
<p>If an unexpected system restart interrupts an operation, it is <span class="sc">implementation defined</span> whether the component state is unchanged, is transitioned to FAILED state, or is processed to a following state by the bootloader as described by the state model. In this situation, the update client must query the component status when it restarts, to determine the result.</p>
</section>
<section id="rationale">
<span id="state-rationale"></span><h3><span class="section-number">4.2.5. </span>Rationale<a class="headerlink" href="#rationale" title="Permalink to this heading">¶</a></h3>
<p>The complexity of the state model is a response to the requirements that follow from the use cases for the Firmware Update API. <span><a class="reference internal" href="#tab-model-rationale"><span class="numref">Table 6</span></a></span> provides a rationale for the state model design.</p>
<table class="colwidths-given longtable docutils align-default" id="tab-model-rationale">
<caption><span class="caption-number">Table 6 </span><span class="caption-text">Use case implications for the state model</span><a class="headerlink" href="#tab-model-rationale" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>State model feature</p></th>
<th class="head"><p>Rationale</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Optional non-volatile WRITING state</p></td>
<td><p>Devices with slow download due to bandwidth or energy constraints can take an extended period to obtain the firmware image. When this is not a constraint, it is more efficient to not need to retain persistent state necessary to resume a download.</p></td>
</tr>
<tr class="row-odd"><td><p>Incremental image transfer in WRITING state</p></td>
<td><p>Devices with limited RAM cannot store the entire image in the update client before writing to the firmware store.</p></td>
</tr>
<tr class="row-even"><td><p>CANDIDATE state</p></td>
<td><p>Enables the update client to explicitly indicate which components are part of an atomic multi-component <code class="docutils literal notranslate"><span class="pre">install</span></code> operation.</p></td>
</tr>
<tr class="row-odd"><td><p>FAILED state</p></td>
<td><p>Enables the update client to detect failed installation operations that occur in the bootloader.</p></td>
</tr>
<tr class="row-even"><td><p>TRIAL and REJECTED states</p></td>
<td><p>Enables a new firmware image to be tested by application firmware, prior to accepting the update, without compromising a firmware rollback-prevention policy.</p></td>
</tr>
<tr class="row-odd"><td><p>UPDATED state and <code class="docutils literal notranslate"><span class="pre">cancel</span></code> operation</p></td>
<td><p>Erasing non-volatile storage can be a high-latency operation. In some systems, this activity might block other memory i/o operations, including code execution. Isolating the erase activity within the <code class="docutils literal notranslate"><span class="pre">clean</span></code> operation enables an update client to manage when such disruptive actions take place.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="verifying-an-update">
<span id="id7"></span><h2><span class="section-number">4.3. </span>Verifying an update<a class="headerlink" href="#verifying-an-update" title="Permalink to this heading">¶</a></h2>
<p>A firmware update is essentially authorized remote code execution. Any security weaknesses in the update process expose that remote code execution system. Failure to secure the firmware update process will help attackers take control of devices.</p>
<p>Where the installation results in the loss of the previous image, verification of the image during a <a class="reference internal" href="../about.html#term-secure-boot"><span class="term">secure boot</span></a> process is not sufficient. If the boot time verification fails, then it is possible that the device can no longer operate, unless additional recovery mechanisms are implemented.</p>
<p>It is important for the update process to verify that an update is appropriate for the device, authentic, correctly authorized, and not expected to result in a non-functioning system. This is achieved by verifying various aspects of the firmware and its manifest. The various checks can take place at different points in the update process, depending on the firmware update implementation architecture — as a result, a verification failure can cause an error response in different function calls depending on the implementation.</p>
<p>The following sections provide example of verification checks that can be implemented as part of the update process.</p>
<section id="manifest-verification">
<span id="id8"></span><h3><span class="section-number">4.3.1. </span>Manifest verification<a class="headerlink" href="#manifest-verification" title="Permalink to this heading">¶</a></h3>
<p>Before processing the content of the manifest, the implementation must verify that the manifest is valid, and authentic. This is typically achieved using a digital signature on the manifest, that can be verified by a trust anchor that is associated with the component.</p>
<p>The manifest must conform to a format that is expected by the implementation. It is recommended that the implementation treats unexpected manifest content as an error.</p>
<p>The manifest describes the type of device, and component, that the firmware is for. The implementation must check that this information matches the device and component being updated.</p>
<p>The manifest provides the version, or sequence number, of the new firmware image. For some deployments, the implementation must not install an earlier version of firmware than is currently installed. This security requirement prevents a firmware downgrade that can expose a known security vulnerability.</p>
<p>The manifest can provide information about dependencies on other firmware images. The implementation must only install the new firmware if its dependencies are satisfied. See <a class="reference internal" href="#dependencies"><span class="secref">Dependencies</span></a>.</p>
<div class="admonition-implementation-note admonition">
<p class="admonition-title">Implementation note</p>
<p>In a trusted-client implementation of the Firmware Update API, these steps can be carried out by the update client, and then no verification is done by the implementation. See <a class="reference internal" href="architecture.html#trusted-client"><span class="secref">Trusted client</span></a>.</p>
</div>
</section>
<section id="firmware-image-verification">
<h3><span class="section-number">4.3.2. </span>Firmware image verification<a class="headerlink" href="#firmware-image-verification" title="Permalink to this heading">¶</a></h3>
<p>Before installation, the firmware integrity must be verified. This can be done by checking that a hash of the firmware image matches the associated value in the manifest, or by checking that a provided image signature matches the firmware image using the trust anchor associated with the component.</p>
<p>In a system that implements <a class="reference internal" href="../about.html#term-secure-boot"><span class="term">secure boot</span></a>, the firmware verification processes that occur during firmware update do not replace the requirement for the bootloader to ensure that only correctly authorized firmware can execute on the device.</p>
<p>The implementation is permitted to defer all of the verification of the manifest and firmware image to the bootloader. However, it is recommended that as much verification as possible is carried out before rebooting the system. This reduces the loss of system availability during a reboot, or the cost of storing the firmware image, when it can be determined ahead of time that the update will fail at least one verification check. This recommendation is also made for systems which repeat the verification in the bootloader, prior to final installation and execution of the new firmware.</p>
<div class="admonition-implementation-note admonition">
<p class="admonition-title">Implementation note</p>
<p>In a trusted-client implementation of the Firmware Update API, this verification can be carried out by the update client, and then no verification is done by the implementation. See <a class="reference internal" href="architecture.html#trusted-client"><span class="secref">Trusted client</span></a>.</p>
</div>
</section>
</section>
<section id="dependencies">
<span id="id9"></span><h2><span class="section-number">4.4. </span>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this heading">¶</a></h2>
<p>A firmware image can have a dependency on another component’s firmware image. When a firmware image has a dependency it cannot be installed until all of its dependencies are satisfied.</p>
<p>A dependency can be satisfied by a firmware image that is already installed, or by a firmware image that is installed at the same time as the dependent image. In the latter case, both images must be prepared as candiate images before the <code class="docutils literal notranslate"><span class="pre">install</span></code> operation. If new firmware images for multiple components are inter-dependent, then the components must be installed at the same time. The <a class="reference internal" href="../appendix/examples.html#multi-component-example"><span class="secref">Multiple components with dependent images</span></a> example shows how this can be done.</p>
<p>Dependencies are typically described in the firmware image manifest. It is the responsibility of the update client to update components in an order that ensures that dependencies are met during the installation process. Typically, the firmware creator and update server ensure that firmware image updates are presented to the update client in an appropriate order. In more advanced systems, a manifest might provide the update client with sufficient information to determine dependencies and installation order of multiple components itself.</p>
<div class="admonition-implementation-note admonition">
<p class="admonition-title">Implementation note</p>
<p>In a trusted-client implementation of the Firmware Update API, dependency verification can be carried out by the update client, and then no verification is done by the implementation. See <a class="reference internal" href="architecture.html#trusted-client"><span class="secref">Trusted client</span></a>.</p>
</div>
</section>
<section id="update-client-operation">
<h2><span class="section-number">4.5. </span>Update client operation<a class="headerlink" href="#update-client-operation" title="Permalink to this heading">¶</a></h2>
<p>A typical sequence of activity relating to a firmware update within a device is as follows:</p>
<ol class="arabic simple">
<li><p>Query the current component status, to determine if an update is required</p></li>
<li><p>Obtain the required manifests and firmware images for the update</p></li>
<li><p>Validate the manifest</p></li>
<li><p>Store the firmware image</p></li>
<li><p>Verify the firmware image</p></li>
<li><p>Invoke the updated firmware image</p></li>
<li><p>Clean up any outdated stored firmware image</p></li>
</ol>
<p>The design of the Firmware Update API offers functions for these actions.</p>
<p>The activity does not always follow this sequence in order. For example,</p>
<ul class="simple">
<li><p>To support devices with constrained download bandwidth, the interface permits an implementation to retain a partially stored firmware image across a system restart. The transfer of the image to the update service can be resumed after the update client has determined the component status.</p></li>
<li><p>For components where the manifest and image are bundled together, the image will be stored prior to verification of the manifest data.</p></li>
<li><p>Some components require execution of the new image to complete verification of the update functionality, before committing to the update.</p></li>
</ul>
<section id="querying-installed-firmware">
<h3><span class="section-number">4.5.1. </span>Querying installed firmware<a class="headerlink" href="#querying-installed-firmware" title="Permalink to this heading">¶</a></h3>
<p>Each component has a local component identifier. Component queries are based on the component identifier.</p>
<p>The update client calls <a class="reference internal" href="../api/api.html#c.psa_fwu_query" title="psa_fwu_query"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_query()</span></code></a> with each component identifier to retrieve information about the component firmware. This information is reported in a <a class="reference internal" href="../api/api.html#c.psa_fwu_component_info_t" title="psa_fwu_component_info_t"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_component_info_t</span></code></a> object, and includes the state of the component, and version of the current active firmware.</p>
<p>If a component state is not READY, the update client should proceed with the appropriate operations to continue or abandon the update that is in progress.</p>
</section>
<section id="preparing-a-new-firmware-image">
<h3><span class="section-number">4.5.2. </span>Preparing a new firmware image<a class="headerlink" href="#preparing-a-new-firmware-image" title="Permalink to this heading">¶</a></h3>
<p>To start this process, the component must be in READY state.</p>
<p>To prepare a new firmware image for a component, the update client calls <a class="reference internal" href="../api/api.html#c.psa_fwu_start" title="psa_fwu_start"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_start()</span></code></a>. For components with a detached manifest, the manifest data is passed as part of the call to <a class="reference internal" href="../api/api.html#c.psa_fwu_start" title="psa_fwu_start"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_start()</span></code></a>. The implementation can verify the manifest at this point, or can defer verification until later in the process.</p>
<p>The update client can now transfer the firmware image data to the firmware store by calling <a class="reference internal" href="../api/api.html#c.psa_fwu_write" title="psa_fwu_write"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_write()</span></code></a> one or more times. In systems with sufficient resources, the firmware image can be transferred in a single call. In systems with limited RAM, the update client can transfer the image incrementally, and specify the location of the provided data within the overall firmware image.</p>
<p>When all of the firmware image has been transferred to the update service, the update client calls <a class="reference internal" href="../api/api.html#c.psa_fwu_finish" title="psa_fwu_finish"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_finish()</span></code></a> to complete the preparation of the candidate firmware image. The implementation can verify the manifest and verify the image at this point, or can defer this until later in the process.</p>
<p>If preparation is successful, the component is now in CANDIDATE state.</p>
<p>To abandon a component update at any stage during the image preparation, the update client calls <a class="reference internal" href="../api/api.html#c.psa_fwu_cancel" title="psa_fwu_cancel"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_cancel()</span></code></a>, and the <a class="reference internal" href="../api/api.html#c.psa_fwu_clean" title="psa_fwu_clean"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_clean()</span></code></a> to remove the abandoned firmware image.</p>
<section id="multi-component-updates">
<span id="id10"></span><h4>Multi-component updates<a class="headerlink" href="#multi-component-updates" title="Permalink to this heading">¶</a></h4>
<p>A system with multiple components might sometimes require that more than one component is updated atomically.</p>
<p>To update multiple components atomically, all of the new firmware images must be prepared as candidates before proceeding to the installation step.</p>
</section>
</section>
<section id="installing-the-candidate-firmware-image">
<h3><span class="section-number">4.5.3. </span>Installing the candidate firmware image<a class="headerlink" href="#installing-the-candidate-firmware-image" title="Permalink to this heading">¶</a></h3>
<p>Once the images have been prepared as candidates, the update client calls <a class="reference internal" href="../api/api.html#c.psa_fwu_install" title="psa_fwu_install"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_install()</span></code></a> to begin the installation process. This operation will apply to all components in CANDIDATE state. The implementation will complete the verification of the manifest data at this point, and can also verify the new firmware image.</p>
<p>Invoking the new firmware image can require part, or all, of the system to be restarted. If this is required, the affected components will be in STAGED state, and the call to <a class="reference internal" href="../api/api.html#c.psa_fwu_install" title="psa_fwu_install"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_install()</span></code></a> returns a status code that informs the update client of the action required.</p>
<p>If a system restart is required, the update client can call <a class="reference internal" href="../api/api.html#c.psa_fwu_request_reboot" title="psa_fwu_request_reboot"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_request_reboot()</span></code></a>. If a component restart is required, this requires an <a class="reference internal" href="../about.html#term-implementation-defined"><span class="scterm">implementation defined</span></a> action by the update client.</p>
<p>When the update requires a system reboot, the bootloader will perform additional manifest and firmware image verification, prior to invoking the new firmware. On restart, the update client must query the component status to determine the result of the installation operation within the bootloader.</p>
<p>If the installation succeeds, the components will be in TRIAL or UPDATED state.</p>
</section>
<section id="testing-the-new-firmware-image">
<h3><span class="section-number">4.5.4. </span>Testing the new firmware image<a class="headerlink" href="#testing-the-new-firmware-image" title="Permalink to this heading">¶</a></h3>
<p>Some components need to execute the new firmware to verify the updated functionality, before accepting the new firmware. For systems that implement a rollback-prevention policy, the testing is done with the component in TRIAL state. The tests are run immediately after the update, and results used to determine whether to accept or reject the update.</p>
<p>The update client reports a successful test result by calling <a class="reference internal" href="../api/api.html#c.psa_fwu_accept" title="psa_fwu_accept"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_accept()</span></code></a>. In an atomic, multi-component update, this will apply to all of the components in the update. The components will now be in UPDATED state.</p>
<p>The update client reports a test failure by calling <a class="reference internal" href="../api/api.html#c.psa_fwu_reject" title="psa_fwu_reject"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_reject()</span></code></a>. In an atomic, multi-component update, this will apply to all of the components in the update. Rolling back to the previous firmware can require part, or all, of the system to be restarted. If this is required, the affected components will be in REJECTED state, and the call to <a class="reference internal" href="../api/api.html#c.psa_fwu_reject" title="psa_fwu_reject"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_reject()</span></code></a> returns a status code that informs the update client of the action required. If a restart is not required, then following the call to <a class="reference internal" href="../api/api.html#c.psa_fwu_reject" title="psa_fwu_reject"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_reject()</span></code></a>, the components will now be in FAILED state.</p>
<p>The updated firmware is automatically rejected if the system restarts while a component is in TRIAL state.</p>
<div class="admonition-implementation-note admonition">
<p class="admonition-title">Implementation note</p>
<p>Where possible, it is recommended that a firmware update can be accepted by the system prior to executing the new firmware. This reduces the complexity of the firmware update process, and reduces risks related to firmware rollback. However, for complex devices that require very reliable, remote update, support for in-field testing of new firmware can be important.</p>
</div>
</section>
<section id="cleaning-up-the-firmware-store">
<h3><span class="section-number">4.5.5. </span>Cleaning up the firmware store<a class="headerlink" href="#cleaning-up-the-firmware-store" title="Permalink to this heading">¶</a></h3>
<p>After a successful, failed, or abandoned update, the storage containing the inactive firmware image needs to be reclaimed for reuse. The update client calls to <a class="reference internal" href="../api/api.html#c.psa_fwu_clean" title="psa_fwu_clean"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_clean()</span></code></a> to do this.</p>
<div class="rationale admonition docutils container">
<p class="admonition-title"><strong>Rationale</strong></p>
<p>Erasing non-volatile storage can be a high-latency operation. In some systems, this activity might block other memory i/o operations, including code execution. Isolating the erase activity within the call to <a class="reference internal" href="../api/api.html#c.psa_fwu_clean" title="psa_fwu_clean"><code class="xref any atg_c atg_c-ref docutils literal notranslate"><span class="pre">psa_fwu_clean()</span></code></a> enables an update client to manage when such disruptive actions take place.</p>
</div>
</section>
</section>
<section id="bootloader-operation">
<h2><span class="section-number">4.6. </span>Bootloader operation<a class="headerlink" href="#bootloader-operation" title="Permalink to this heading">¶</a></h2>
<p>When the bootloader is involved in the firmware installation process, it does more than select and verify a firmware image to execute. This section describes the responsibilities of the bootloader for the type of component depicted in <a class="reference internal" href="#state-transitions"><span class="secref">State transitions</span></a>.</p>
<section id="determine-firmware-state">
<h3><span class="section-number">4.6.1. </span>Determine firmware state<a class="headerlink" href="#determine-firmware-state" title="Permalink to this heading">¶</a></h3>
<p>The bootloader checks the state of each component:</p>
<ul class="simple">
<li><p>If there are any STAGED components, proceed to install them. See <a class="reference internal" href="#boot-install"><span class="secref">Install components</span></a>.</p></li>
<li><p>If there are any TRIAL or REJECTED components, proceed to roll them back. See <a class="reference internal" href="#boot-rollback"><span class="secref">Rollback trial components</span></a>.</p></li>
<li><p>If staging is volatile, and there are any WRITING, FAILED, or UPDATED components, proceed to clean their firmware store.</p></li>
<li><p>Otherwise, proceed to boot the firmware. See <a class="reference internal" href="#boot-execute"><span class="secref">Authenticate and execute active firmware</span></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The design of the state model prevents the situation in which there is a STAGED component at the same time as a TRIAL or REJECTED component.</p>
</div>
</section>
<section id="install-components">
<span id="boot-install"></span><h3><span class="section-number">4.6.2. </span>Install components<a class="headerlink" href="#install-components" title="Permalink to this heading">¶</a></h3>
<p>If the implementation defers verification of the updated firmware to the bootloader, or the bootloader does not trust the staged firmware image (see <a class="reference internal" href="architecture.html#untrusted-staging"><span class="secref">Untrusted staging</span></a>), the bootloader must verify all components that are in STAGED state. If verification fails, all STAGED components are set to FAILED state, and the reason for failure stored for retrieval by the update client. The bootloader proceeds to boot the existing firmware. See <a class="reference internal" href="#boot-execute"><span class="secref">Authenticate and execute active firmware</span></a>.</p>
<p>The new firmware images for all STAGED components are installed as the <em>active</em> firmware. If the installation fails for any component, the previous images are restored for all components, the components are set to FAILED state, and the reason for failure stored for retrieval by the update client. The bootloader proceeds to boot the existing firmware. See <a class="reference internal" href="#boot-execute"><span class="secref">Authenticate and execute active firmware</span></a>.</p>
<p>If the components require the new firmware to be tested before acceptance, the bootloader stores the previously <em>active</em> firmware images as backup, for recovery if the new firmware images fail. The components are set to TRIAL state, and the bootloader proceeds to boot the new firmware. See <a class="reference internal" href="#boot-execute"><span class="secref">Authenticate and execute active firmware</span></a>.</p>
<p>Otherwise, the components are set to UPDATED state, and the bootloader proceeds to boot the new firmware. See <a class="reference internal" href="#boot-execute"><span class="secref">Authenticate and execute active firmware</span></a>.</p>
</section>
<section id="rollback-trial-components">
<span id="boot-rollback"></span><h3><span class="section-number">4.6.3. </span>Rollback trial components<a class="headerlink" href="#rollback-trial-components" title="Permalink to this heading">¶</a></h3>
<p>If the system restarts while components are in TRIAL state, or after an update has been explicitly rejected by the update client, the bootloader restores the previous firmware images for the affected components as the <em>active</em> image. These images were stored as a backup during the installation of the firmware being tested (see <a class="reference internal" href="#boot-install"><span class="secref">Install components</span></a>).</p>
<p>The components are set to FAILED state, and the reason for failure stored for retrieval by the update client. This will result in the firmware images, that failed the trial, being erased when the update client carries out a <code class="docutils literal notranslate"><span class="pre">clean</span></code> operation.</p>
<p>The bootloader proceeds to boot the previous firmware. See <a class="reference internal" href="#boot-execute"><span class="secref">Authenticate and execute active firmware</span></a>.</p>
</section>
<section id="authenticate-and-execute-active-firmware">
<span id="boot-execute"></span><h3><span class="section-number">4.6.4. </span>Authenticate and execute <em>active</em> firmware<a class="headerlink" href="#authenticate-and-execute-active-firmware" title="Permalink to this heading">¶</a></h3>
<p>In a system that implements a <a class="reference internal" href="../about.html#term-secure-boot"><span class="term">secure boot</span></a> policy, the bootloader verifies the integrity and authenticity of the <em>active</em> firmware. If this verification fails, the result is <a class="reference internal" href="../about.html#term-implementation-defined"><span class="scterm">implementation defined</span></a>, for example:</p>
<ul class="simple">
<li><p>The bootloader can rollback to a previous firmware image, if one is available and policy permits.</p></li>
<li><p>The bootloader can run a special recovery firmware image, if this is provided by the system.</p></li>
<li><p>The device can become non-functional and unrecoverable.</p></li>
</ul>
<p>Otherwise, the bootloader will complete initialization and transfer execution to the <em>active</em> firmware image.</p>
</section>
</section>
<section id="sample-sequence-during-firmware-update">
<h2><span class="section-number">4.7. </span>Sample sequence during firmware update<a class="headerlink" href="#sample-sequence-during-firmware-update" title="Permalink to this heading">¶</a></h2>
<p><span><a class="reference internal" href="#fig-sequence"><span class="numref">Figure 8</span></a></span> is a detailed sequence diagram shows how the overall logic could be implemented.</p>
<figure class="align-default" id="fig-sequence">
<a class="reference internal image-reference" href="../_images/sequence.svg"><img alt="../_images/sequence.svg" height="875" src="../_images/sequence.svg" width="511" /></a>
<figcaption>
<p><span class="caption-number">Figure 8 </span><span class="caption-text">A sequence diagram showing an example flow</span><a class="headerlink" href="#fig-sequence" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/Arm_logo_blue_RGB.svg" alt="Logo"/>
            </a></p><hr />
<h3><a href="../index.html"><b>PSA Certified<br />Firmware Update API</b></a></h3>
IHI 0093<br/>
Non-confidential<br/>
Version 1.0.0
<hr />
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About this document</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="goals.html">2. Design goals</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">3. Architecture</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Programming model</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-firmware-store">4.1. The firmware store</a></li>
<li class="toctree-l2"><a class="reference internal" href="#state-model">4.2. State model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#component-state">4.2.1. Component state</a></li>
<li class="toctree-l3"><a class="reference internal" href="#volatile-states">4.2.2. Volatile states</a></li>
<li class="toctree-l3"><a class="reference internal" href="#state-transitions">4.2.3. State transitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#behavior-on-error">4.2.4. Behavior on error</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rationale">4.2.5. Rationale</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#verifying-an-update">4.3. Verifying an update</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#manifest-verification">4.3.1. Manifest verification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#firmware-image-verification">4.3.2. Firmware image verification</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dependencies">4.4. Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#update-client-operation">4.5. Update client operation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#querying-installed-firmware">4.5.1. Querying installed firmware</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preparing-a-new-firmware-image">4.5.2. Preparing a new firmware image</a></li>
<li class="toctree-l3"><a class="reference internal" href="#installing-the-candidate-firmware-image">4.5.3. Installing the candidate firmware image</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-the-new-firmware-image">4.5.4. Testing the new firmware image</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cleaning-up-the-firmware-store">4.5.5. Cleaning up the firmware store</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bootloader-operation">4.6. Bootloader operation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#determine-firmware-state">4.6.1. Determine firmware state</a></li>
<li class="toctree-l3"><a class="reference internal" href="#install-components">4.6.2. Install components</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rollback-trial-components">4.6.3. Rollback trial components</a></li>
<li class="toctree-l3"><a class="reference internal" href="#authenticate-and-execute-active-firmware">4.6.4. Authenticate and execute <em>active</em> firmware</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sample-sequence-during-firmware-update">4.7. Sample sequence during firmware update</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/api.html">5. API reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix/example-header.html">A. Example header file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/examples.html">B. Example usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/variations.html">C. Variation in system design parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/sra.html">D. Security Risk Assessment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/change-history.html">E. Document change history</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../atg_c-identifiers.html">Index of API elements</a></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; 2020-2023 Arm Limited and/or its affiliates.
      
    </div>

    

    
  </body>
</html>