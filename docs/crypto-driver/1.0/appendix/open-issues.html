<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="1 Open questions" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://arm-software.github.io/psa-api/crypto-driver/1.0/appendix/open-issues.html" />
<link rel="canonical" href="https://arm-software.github.io/psa-api/crypto-driver/1.0/appendix/open-issues.html" />
<meta property="og:site_name" content="PSA Certified Crypto Driver Interface 1.0" />
<meta property="og:description" content="Alpha Value representation: Integers: It would be better if there was a uniform requirement on integer values. Do they have to be JSON integers? C preprocessor integers (which could be e.g. a macro..." />
<meta name="description" content="Alpha Value representation: Integers: It would be better if there was a uniform requirement on integer values. Do they have to be JSON integers? C preprocessor integers (which could be e.g. a macro..." />

    <title>1 Open questions &#8212; PSA Certified Crypto Driver Interface 1.0</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=f6a572b4" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
    <link rel="preconnect" type="text/css" href="https://fonts.googleapis.com" />
    <link rel="preconnect" type="text/css" href="https://fonts.gstatic.com" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;1,300;1,400&display=swap" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Noto+Sans+Mono:ital,wght@0,300;0,400;1,300&display=swap" />
    <script src="../_static/documentation_options.js?v=d052748e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2 Changes to the API" href="history.html" />
    <link rel="prev" title="7 Using drivers from an application" href="../body/using-drivers.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/ARM_LOGO-2025_INK_RGB.svg" alt="Logo of PSA Certified Crypto Driver Interface"/>
            </a></p><hr />
<h3><a href="../index.html">PSA Certified<br />Crypto Driver Interface</a></h3>
111106<br/>
Non-confidential<br/>
Version 1.0 Alpha (Issue 1)
<hr />
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about/about.html">About this document</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../body/introduction.html">1 Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../body/overview.html">2 Overview of drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../body/manifest.html">3 Driver description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../body/entry-points.html">4 Driver entry points</a></li>
<li class="toctree-l1"><a class="reference internal" href="../body/transparent.html">5 Transparent drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../body/opaque.html">6 Opaque drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../body/using-drivers.html">7 Using drivers from an application</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">A Open questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#value-representation">A.1 Value representation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#integers">A.1.1 Integers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#driver-declarations">A.2 Driver declarations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#declaring-driver-entry-points">A.2.1 Declaring driver entry points</a></li>
<li class="toctree-l3"><a class="reference internal" href="#driver-location-values">A.2.2 Driver location values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-transparent-drivers">A.2.3 Multiple transparent drivers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#driver-function-interfaces">A.3 Driver function interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#driver-function-parameter-conventions">A.3.1 Driver function parameter conventions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#key-derivation-inputs-and-buffer-ownership">A.3.2 Key derivation inputs and buffer ownership</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#partial-computations-in-drivers">A.4 Partial computations in drivers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#substitution-points">A.4.1 Substitution points</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#key-management">A.5 Key management</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mixing-drivers-in-key-derivation">A.5.1 Mixing drivers in key derivation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#public-key-calculation">A.5.2 Public key calculation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#symmetric-key-validation-with-transparent-drivers">A.5.3 Symmetric key validation with transparent drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#support-for-custom-import-formats">A.5.4 Support for custom import formats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#opaque-drivers">A.6 Opaque drivers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#opaque-driver-persistent-state">A.6.1 Opaque driver persistent state</a></li>
<li class="toctree-l3"><a class="reference internal" href="#open-questions-around-cooked-key-derivation">A.6.2 Open questions around cooked key derivation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fallback-for-key-derivation-in-opaque-drivers">A.6.3 Fallback for key derivation in opaque drivers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#randomness">A.7 Randomness</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#input-to-add-entropy">A.7.1 Input to <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#flags-for-get-entropy">A.7.2 Flags for <code class="docutils literal notranslate"><span class="pre">&quot;get_entropy&quot;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#random-generator-instantiations">A.7.3 Random generator instantiations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="history.html">B Changes to the API</a></li>
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="watermark docutils container">
<p>Alpha</p>
</div>
<section id="open-questions">
<span id="open-issues"></span><h1><span class="section-number">A </span>Open questions<a class="headerlink" href="#open-questions" title="Link to this heading">¶</a></h1>
<section id="value-representation">
<h2><span class="section-number">A.1 </span>Value representation<a class="headerlink" href="#value-representation" title="Link to this heading">¶</a></h2>
<section id="integers">
<h3><span class="section-number">A.1.1 </span>Integers<a class="headerlink" href="#integers" title="Link to this heading">¶</a></h3>
<p>It would be better if there was a uniform requirement on integer values.
Do they have to be JSON integers? C preprocessor integers (which could be e.g. a macro defined in some header file)? C compile-time constants (allowing <code class="docutils literal notranslate"><span class="pre">sizeof</span></code>)?</p>
<p>This choice is partly driven by the use of the values, so they might not be uniform.
Note that if the value can be zero and it’s plausible that the core would want to statically allocate an array of the given size, the core needs to know whether the value is 0 so that it could use code like</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#if ACME_FOO_SIZE != 0
    uint8_t foo[ACME_FOO_SIZE];
#endif
</pre></div>
</div>
</section>
</section>
<section id="driver-declarations">
<h2><span class="section-number">A.2 </span>Driver declarations<a class="headerlink" href="#driver-declarations" title="Link to this heading">¶</a></h2>
<section id="declaring-driver-entry-points">
<h3><span class="section-number">A.2.1 </span>Declaring driver entry points<a class="headerlink" href="#declaring-driver-entry-points" title="Link to this heading">¶</a></h3>
<p>The core may want to provide declarations for the driver entry points so that it can compile code using them.
At the time of writing this paragraph, the driver headers must define types but there is no obligation for them to declare functions.
The core knows what the function names and argument types are, so it can generate prototypes.</p>
<p>It should be ok for driver functions to be function-like macros or function pointers.</p>
</section>
<section id="driver-location-values">
<h3><span class="section-number">A.2.2 </span>Driver location values<a class="headerlink" href="#driver-location-values" title="Link to this heading">¶</a></h3>
<p>How does a driver author decide which location values to use? It should be possible to combine drivers from different sources.
Use the same vendor assignment as for PSA services?</p>
<p>Can the driver assembly process generate distinct location values as needed? This can be convenient, but it’s also risky: if you upgrade a device, you need the location values to be the same between builds.</p>
<p>The current plan is for Arm to maintain a registry of vendors and assign a location namespace to each vendor.
Parts of the namespace would be reserved for implementations and integrators.</p>
</section>
<section id="multiple-transparent-drivers">
<h3><span class="section-number">A.2.3 </span>Multiple transparent drivers<a class="headerlink" href="#multiple-transparent-drivers" title="Link to this heading">¶</a></h3>
<p>When multiple transparent drivers implement the same mechanism, which one is called? The first one? The last one? Unspecified? Or is this an error (excluding capabilities with fallback enabled)?</p>
<p>The current choice is that the first one is used, which allows having a preference order on drivers, but may mask integration errors.</p>
</section>
</section>
<section id="driver-function-interfaces">
<h2><span class="section-number">A.3 </span>Driver function interfaces<a class="headerlink" href="#driver-function-interfaces" title="Link to this heading">¶</a></h2>
<section id="driver-function-parameter-conventions">
<h3><span class="section-number">A.3.1 </span>Driver function parameter conventions<a class="headerlink" href="#driver-function-parameter-conventions" title="Link to this heading">¶</a></h3>
<p>Should 0-size buffers be guaranteed to have a non-null pointers?</p>
<p>Should drivers really have to cope with overlap?</p>
<p>Should the core guarantee that the output buffer size has the size indicated by the applicable buffer size macro (which may be an overestimation)?</p>
</section>
<section id="key-derivation-inputs-and-buffer-ownership">
<span id="id1"></span><h3><span class="section-number">A.3.2 </span>Key derivation inputs and buffer ownership<a class="headerlink" href="#key-derivation-inputs-and-buffer-ownership" title="Link to this heading">¶</a></h3>
<p>Why is <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_bytes</span></code> a copy, rather than giving a pointer?</p>
<p>The main reason is to avoid complex buffer ownership.
A driver entry point does not own memory after the entry point return.
This is generally necessary because an API function does not own memory after the entry point returns.
In the case of key derivation inputs, this could be relaxed because the driver entry point is making callbacks to the core: these functions could return a pointer that is valid until the driver entry point returns, which would allow the driver to process the data immediately (e.g. hash it rather than copy it).</p>
</section>
</section>
<section id="partial-computations-in-drivers">
<h2><span class="section-number">A.4 </span>Partial computations in drivers<a class="headerlink" href="#partial-computations-in-drivers" title="Link to this heading">¶</a></h2>
<section id="substitution-points">
<h3><span class="section-number">A.4.1 </span>Substitution points<a class="headerlink" href="#substitution-points" title="Link to this heading">¶</a></h3>
<p>Earlier drafts of the driver interface had a concept of <em>substitution points</em>: places in the calculation where a driver may be called.
Some hardware doesn’t do the whole calculation, but only the “main” part.
This goes both for transparent and opaque drivers.
Some common examples:</p>
<ul class="simple">
<li><p>A processor that performs the RSA exponentiation, but not the padding.
The driver should be able to leverage the padding code in the core.</p></li>
<li><p>A processor that performs a block cipher operation only for a single block, or only in ECB mode, or only in CTR mode.
The core would perform the block mode (CBC, CTR, CCM, …).</p></li>
</ul>
<p>This concept, or some other way to reuse portable code such as specifying inner functions like <code class="docutils literal notranslate"><span class="pre">psa_rsa_pad</span></code> in the core, should be added to the specification.</p>
</section>
</section>
<section id="key-management">
<h2><span class="section-number">A.5 </span>Key management<a class="headerlink" href="#key-management" title="Link to this heading">¶</a></h2>
<section id="mixing-drivers-in-key-derivation">
<h3><span class="section-number">A.5.1 </span>Mixing drivers in key derivation<a class="headerlink" href="#mixing-drivers-in-key-derivation" title="Link to this heading">¶</a></h3>
<p>How does <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_output_key</span></code> work when the extraction part and the expansion part use different drivers?</p>
</section>
<section id="public-key-calculation">
<h3><span class="section-number">A.5.2 </span>Public key calculation<a class="headerlink" href="#public-key-calculation" title="Link to this heading">¶</a></h3>
<p>ECC key pairs are represented as the private key value only.
The public key needs to be calculated from that.
Both transparent drivers and opaque drivers provide a function to calculate the public key (<code class="docutils literal notranslate"><span class="pre">&quot;export_public_key&quot;</span></code>).</p>
<p>The specification doesn’t mention when the public key might be calculated.
The core may calculate it on creation, on demand, or anything in between.
Opaque drivers have a choice of storing the public key in the key context or calculating it on demand and can convey whether the core should store the public key with the <code class="docutils literal notranslate"><span class="pre">&quot;store_public_key&quot;</span></code> property.
Is this good enough or should the specification include non-functional requirements?</p>
</section>
<section id="symmetric-key-validation-with-transparent-drivers">
<h3><span class="section-number">A.5.3 </span>Symmetric key validation with transparent drivers<a class="headerlink" href="#symmetric-key-validation-with-transparent-drivers" title="Link to this heading">¶</a></h3>
<p>Should the entry point be called for symmetric keys as well?</p>
</section>
<section id="support-for-custom-import-formats">
<h3><span class="section-number">A.5.4 </span>Support for custom import formats<a class="headerlink" href="#support-for-custom-import-formats" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../body/entry-points.html#driver-entry-points-for-key-management"><span class="secref">Driver entry points for key management</span></a> states that the input to <code class="docutils literal notranslate"><span class="pre">&quot;import_key&quot;</span></code> can be an implementation-defined format.
Is this a good idea? It reduces driver portability, since a core that accepts a custom format would not work with a driver that doesn’t accept this format.
On the other hand, if a driver accepts a custom format, the core should let it through because the driver presumably handles it more efficiently (in terms of speed and code size) than the core could.</p>
<p>Allowing custom formats also causes a problem with import: the core can’t know the size of the key representation until it knows the bit-size of the key, but determining the bit-size of the key is part of the job of the <code class="docutils literal notranslate"><span class="pre">&quot;import_key&quot;</span></code> entry point.
For standard key types, this could plausibly be an issue for RSA private keys, where an implementation might accept a custom format that omits the CRT parameters (or that omits <em>d</em>).</p>
</section>
</section>
<section id="opaque-drivers">
<h2><span class="section-number">A.6 </span>Opaque drivers<a class="headerlink" href="#opaque-drivers" title="Link to this heading">¶</a></h2>
<section id="opaque-driver-persistent-state">
<h3><span class="section-number">A.6.1 </span>Opaque driver persistent state<a class="headerlink" href="#opaque-driver-persistent-state" title="Link to this heading">¶</a></h3>
<p>The driver is allowed to update the state at any time.
Is this ok?</p>
<p>An example use case for updating the persistent state at arbitrary times is to renew a key that is used to encrypt communications between the application processor and the secure element.</p>
<p><code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_get_persistent_state</span></code> does not identify the calling driver, so the driver needs to remember which driver it’s calling.
This may require a thread-local variable in a multithreaded core.
Is this ok?</p>
</section>
<section id="open-questions-around-cooked-key-derivation">
<span id="cooked-key-derivation-issue"></span><h3><span class="section-number">A.6.2 </span>Open questions around cooked key derivation<a class="headerlink" href="#open-questions-around-cooked-key-derivation" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">&quot;derive_key&quot;</span></code> is not a clear name.
Can we use a better one?</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">&quot;derive_key&quot;</span></code> entry point, how does the core choose <code class="docutils literal notranslate"><span class="pre">input_length</span></code>? Doesn’t the driver know better? Should there be a driver entry point to determine the length, or should there be a callback that allows the driver to retrieve the input? Note that for some key types, it’s impossible to predict the amount of input in advance, because it depends on some complex calculation or even on random data, e.g. if doing a randomized pseudo-primality test.
However, for all key types except RSA, the specification mandates how the key is derived, which practically dictates how the pseudorandom key stream is consumed.
So it’s probably ok.</p>
</section>
<section id="fallback-for-key-derivation-in-opaque-drivers">
<span id="id2"></span><h3><span class="section-number">A.6.3 </span>Fallback for key derivation in opaque drivers<a class="headerlink" href="#fallback-for-key-derivation-in-opaque-drivers" title="Link to this heading">¶</a></h3>
<p>Should <a class="reference internal" href="../body/entry-points.html#key-derivation-driver-dispatch-logic"><span class="std std-ref">dispatch to an opaque driver</span></a> allow fallback, so that if <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_setup&quot;</span></code> returns <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_NOT_SUPPORTED</span></code> then the core exports the key from the secure element instead?</p>
<p>Should the <a class="reference internal" href="../body/entry-points.html#key-derivation-driver-outputs"><span class="std std-ref">&quot;key_derivation_output_key&quot;</span></a> capability indicate which key types the driver can derive? How should fallback work? For example, consider a secure element that implements HMAC, HKDF and ECDSA, and that can derive an HMAC key from HKDF without exporting intermediate material but can only import or randomly generate ECC keys.
How does this driver convey that it can’t derive an ECC key with HKDF, but it can let the core do this and import the resulting key?</p>
</section>
</section>
<section id="randomness">
<h2><span class="section-number">A.7 </span>Randomness<a class="headerlink" href="#randomness" title="Link to this heading">¶</a></h2>
<section id="input-to-add-entropy">
<h3><span class="section-number">A.7.1 </span>Input to <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code><a class="headerlink" href="#input-to-add-entropy" title="Link to this heading">¶</a></h3>
<p>Should the input to the <a class="reference internal" href="../body/transparent.html#entropy-injection"><span class="std std-ref">&quot;add_entropy&quot; entry point</span></a> be a full-entropy buffer (with data from all entropy sources already mixed), raw entropy direct from the entropy sources, or give the core a choice?</p>
<ul class="simple">
<li><p>Raw data: drivers must implement entropy mixing.
<code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> needs an extra parameter to indicate the amount of entropy in the data.
The core must not do any conditioning.</p></li>
<li><p>Choice: drivers must implement entropy mixing.
<code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> needs an extra parameter to indicate the amount of entropy in the data.
The core may do conditioning if it wants, but doesn’t have to.</p></li>
<li><p>Full entropy: drivers don’t need to do entropy mixing.</p></li>
</ul>
</section>
<section id="flags-for-get-entropy">
<h3><span class="section-number">A.7.2 </span>Flags for <code class="docutils literal notranslate"><span class="pre">&quot;get_entropy&quot;</span></code><a class="headerlink" href="#flags-for-get-entropy" title="Link to this heading">¶</a></h3>
<p>Are the <a class="reference internal" href="../body/entry-points.html#entropy-collection-flags"><span class="std std-ref">entropy collection flags</span></a> well-chosen?</p>
</section>
<section id="random-generator-instantiations">
<h3><span class="section-number">A.7.3 </span>Random generator instantiations<a class="headerlink" href="#random-generator-instantiations" title="Link to this heading">¶</a></h3>
<p>May the core instantiate a random generation context more than once? In other words, can there be multiple objects of type <code class="docutils literal notranslate"><span class="pre">acme_random_context_t</span></code>?</p>
<p>Functionally, one RNG is as good as any.
If the core wants some parts of the system to use a deterministic generator for reproducibility, it can’t use this interface anyway, since the RNG is not necessarily deterministic.
However, for performance on multiprocessor systems, a multithreaded core could prefer to use one RNG instance per thread.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169; 2020-2025 Arm Limited and/or its affiliates.
      
    </div>

    

    
  </body>
</html>