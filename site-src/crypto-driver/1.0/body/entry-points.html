---
---

<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="4 Driver entry points" />
<meta property="og:type" content="website" />
<meta property="og:url" content="{{ page.url | absolute_url }}" />
<link rel="canonical" href="{{ page.url | absolute_url }}" />
<meta property="og:site_name" content="PSA Certified Crypto Driver Interface 1.0" />
<meta property="og:description" content="Alpha Overview of driver entry points: Drivers define functions, each of which implements an aspect of a capability of a driver, such as a cryptographic operation, a part of a cryptographic operati..." />
<meta name="description" content="Alpha Overview of driver entry points: Drivers define functions, each of which implements an aspect of a capability of a driver, such as a cryptographic operation, a part of a cryptographic operati..." />

    <title>4 Driver entry points &#8212; PSA Certified Crypto Driver Interface 1.0</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=f6a572b4" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
    <link rel="preconnect" type="text/css" href="https://fonts.googleapis.com" />
    <link rel="preconnect" type="text/css" href="https://fonts.gstatic.com" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;1,300;1,400&display=swap" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Noto+Sans+Mono:ital,wght@0,300;0,400;1,300&display=swap" />
    <script src="../_static/documentation_options.js?v=d052748e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5 Transparent drivers" href="transparent.html" />
    <link rel="prev" title="3 Driver description" href="manifest.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/ARM_LOGO-2025_INK_RGB.svg" alt="Logo of PSA Certified Crypto Driver Interface"/>
            </a></p><hr />
<h3><a href="../index.html">PSA Certified<br />Crypto Driver Interface</a></h3>
111106<br/>
Non-confidential<br/>
Version 1.0 Alpha (Issue 1)
<hr />
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about/about.html">About this document</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1 Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">2 Overview of drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="manifest.html">3 Driver description</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4 Driver entry points</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview-of-driver-entry-points">4.1 Overview of driver entry points</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#general-considerations-on-driver-entry-point-parameters">4.1.1 General considerations on driver entry point parameters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#driver-entry-points-for-single-part-cryptographic-operations">4.2 Driver entry points for single-part cryptographic operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#driver-entry-points-for-multi-part-operations">4.3 Driver entry points for multi-part operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#general-considerations-on-multi-part-operations">4.3.1 General considerations on multi-part operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multi-part-operation-entry-point-family-hash-multipart">4.3.2 Multi-part operation entry point family <code class="docutils literal notranslate"><span class="pre">&quot;hash_multipart&quot;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#operation-family-mac-multipart">4.3.3 Operation family <code class="docutils literal notranslate"><span class="pre">&quot;mac_multipart&quot;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#operation-family-mac-verify-multipart">4.3.4 Operation family <code class="docutils literal notranslate"><span class="pre">&quot;mac_verify_multipart&quot;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#operation-family-cipher-encrypt-multipart">4.3.5 Operation family <code class="docutils literal notranslate"><span class="pre">&quot;cipher_encrypt_multipart&quot;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#operation-family-cipher-decrypt-multipart">4.3.6 Operation family <code class="docutils literal notranslate"><span class="pre">&quot;cipher_decrypt_multipart&quot;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#operation-family-aead-encrypt-multipart">4.3.7 Operation family <code class="docutils literal notranslate"><span class="pre">&quot;aead_encrypt_multipart&quot;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#operation-family-aead-decrypt-multipart">4.3.8 Operation family <code class="docutils literal notranslate"><span class="pre">&quot;aead_decrypt_multipart&quot;</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#driver-entry-points-for-key-derivation">4.4 Driver entry points for key derivation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#key-derivation-driver-dispatch-logic">4.4.1 Key derivation driver dispatch logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summary-of-entry-points-for-the-operation-family-key-derivation">4.4.2 Summary of entry points for the operation family <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation&quot;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#key-derivation-driver-initial-inputs">4.4.3 Key derivation driver initial inputs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#key-derivation-driver-setup">4.4.4 Key derivation driver setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#key-derivation-driver-long-inputs">4.4.5 Key derivation driver long inputs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#key-derivation-driver-operation-capacity">4.4.6 Key derivation driver operation capacity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#key-derivation-driver-outputs">4.4.7 Key derivation driver outputs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transparent-cooked-key-derivation">4.4.8 Transparent cooked key derivation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#key-agreement">4.4.9 Key agreement</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#driver-entry-points-for-pake">4.5 Driver entry points for PAKE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pake-driver-dispatch-logic">4.5.1 PAKE driver dispatch logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summary-of-entry-points-for-pake">4.5.2 Summary of entry points for PAKE</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pake-driver-inputs">4.5.3 PAKE driver inputs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pake-driver-setup">4.5.4 PAKE driver setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pake-driver-output">4.5.5 PAKE driver output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pake-driver-input">4.5.6 PAKE driver input</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pake-driver-get-implicit-key">4.5.7 PAKE driver get implicit key</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#driver-entry-points-for-key-management">4.6 Driver entry points for key management</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#key-size-determination-on-import">4.6.1 Key size determination on import</a></li>
<li class="toctree-l3"><a class="reference internal" href="#key-validation">4.6.2 Key validation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#entropy-collection-entry-point">4.7 Entropy collection entry point</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#entropy-collection-flags">4.7.1 Entropy collection flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="#entropy-collection-and-blocking">4.7.2 Entropy collection and blocking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#miscellaneous-driver-entry-points">4.8 Miscellaneous driver entry points</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#driver-initialization">4.8.1 Driver initialization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#combining-multiple-drivers">4.9 Combining multiple drivers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="transparent.html">5 Transparent drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="opaque.html">6 Opaque drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-drivers.html">7 Using drivers from an application</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix/open-issues.html">A Open questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/history.html">B Changes to the API</a></li>
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="watermark docutils container">
<p>Alpha</p>
</div>
<section id="driver-entry-points">
<span id="id1"></span><h1><span class="section-number">4 </span>Driver entry points<a class="headerlink" href="#driver-entry-points" title="Link to this heading">¶</a></h1>
<section id="overview-of-driver-entry-points">
<h2><span class="section-number">4.1 </span>Overview of driver entry points<a class="headerlink" href="#overview-of-driver-entry-points" title="Link to this heading">¶</a></h2>
<p>Drivers define functions, each of which implements an aspect of a capability of a driver, such as a cryptographic operation, a part of a cryptographic operation, or a key management action.
These functions are called the <strong>entry points</strong> of the driver.
Most driver entry points correspond to a particular function in the Crypto API.
For example, if a call to <code class="docutils literal notranslate"><span class="pre">psa_sign_hash()</span></code> is dispatched to a driver, it invokes the driver’s <code class="docutils literal notranslate"><span class="pre">sign_hash</span></code> function.</p>
<p>All driver entry points return a status of type <code class="docutils literal notranslate"><span class="pre">psa_status_t</span></code> which should use the status codes documented for PSA services in general and for the Crypto API.
In particular: <code class="docutils literal notranslate"><span class="pre">PSA_SUCCESS</span></code> indicates that the function succeeded, and <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_xxx</span></code> values indicate that an error occurred.</p>
<p>The signature of a driver entry point generally looks like the signature of the Crypto API that it implements, with some modifications.
This section gives an overview of modifications that apply to whole classes of entry points.
Refer to the reference section for each entry point or entry point family for details.</p>
<ul>
<li><p>For entry points that operate on an existing key, the <code class="docutils literal notranslate"><span class="pre">psa_key_id_t</span></code> parameter is replaced by a sequence of three parameters that describe the key:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">psa_key_attributes_t</span> <span class="pre">*attributes</span></code>: the key attributes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*key_buffer</span></code>: a key material or key context buffer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">key_buffer_size</span></code>: the size of the key buffer in bytes.</p></li>
</ol>
<p>For transparent drivers, the key buffer contains the key material, in the same format as defined for <code class="docutils literal notranslate"><span class="pre">psa_export_key()</span></code> and <code class="docutils literal notranslate"><span class="pre">psa_export_public_key()</span></code> in the Crypto API.
For opaque drivers, the content of the key buffer is entirely up to the driver.</p>
</li>
<li><p>For entry points that involve a multi-part operation, the operation state type (<code class="docutils literal notranslate"><span class="pre">psa_XXX_operation_t</span></code>) is replaced by a driver-specific operation state type (<em>prefix</em><code class="docutils literal notranslate"><span class="pre">_XXX_operation_t</span></code>).</p></li>
<li><p>For entry points that are involved in key creation, the <code class="docutils literal notranslate"><span class="pre">psa_key_id_t</span> <span class="pre">*</span></code> output parameter is replaced by a sequence of parameters that convey the key context:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*key_buffer</span></code>: a buffer for the key material or key context.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">key_buffer_size</span></code>: the size of the key buffer in bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*key_buffer_length</span></code>: the length of the data written to the key buffer in bytes.</p></li>
</ol>
</li>
</ul>
<p>Some entry points are grouped in families that must be implemented as a whole.
If a driver supports an entry point family, it must provide all the entry points in the family.</p>
<p>Drivers can also have entry points related to random generation.
A transparent driver can provide a <a class="reference internal" href="transparent.html#random-generation-entry-points"><span class="std std-ref">random generation interface</span></a>.
Separately, transparent and opaque drivers can have <a class="reference internal" href="#entropy-collection-entry-point"><span class="std std-ref">entropy collection entry points</span></a>.</p>
<section id="general-considerations-on-driver-entry-point-parameters">
<h3><span class="section-number">4.1.1 </span>General considerations on driver entry point parameters<a class="headerlink" href="#general-considerations-on-driver-entry-point-parameters" title="Link to this heading">¶</a></h3>
<p>Buffer parameters for driver entry points obey the following conventions:</p>
<ul class="simple">
<li><p>An input buffer has the type <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span></code> and is immediately followed by a parameter of type <code class="docutils literal notranslate"><span class="pre">size_t</span></code> that indicates the buffer size.</p></li>
<li><p>An output buffer has the type <code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*</span></code> and is immediately followed by a parameter of type <code class="docutils literal notranslate"><span class="pre">size_t</span></code> that indicates the buffer size.
A third parameter of type <code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span></code> is provided to report the actual length of the data written in the buffer if the function succeeds.</p></li>
<li><p>An in-out buffer has the type <code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*</span></code> and is immediately followed by a parameter of type <code class="docutils literal notranslate"><span class="pre">size_t</span></code> that indicates the buffer size.
In-out buffers are only used when the input and the output have the same length.</p></li>
</ul>
<p>Buffers of size 0 may be represented with either a null pointer or a non-null pointer.</p>
<p>Input buffers and other input-only parameters (<code class="docutils literal notranslate"><span class="pre">const</span></code> pointers) may be in read-only memory.
Overlap is possible between input buffers, and between an input buffer and an output buffer, but not between two output buffers or between a non-buffer parameter and another parameter.</p>
</section>
</section>
<section id="driver-entry-points-for-single-part-cryptographic-operations">
<h2><span class="section-number">4.2 </span>Driver entry points for single-part cryptographic operations<a class="headerlink" href="#driver-entry-points-for-single-part-cryptographic-operations" title="Link to this heading">¶</a></h2>
<p>The following driver entry points perform a cryptographic operation in one shot (single-part operation):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;hash_compute&quot;</span></code> (transparent drivers only): calculation of a hash.
Called by <code class="docutils literal notranslate"><span class="pre">psa_hash_compute()</span></code> and <code class="docutils literal notranslate"><span class="pre">psa_hash_compare()</span></code>.
To verify a hash with <code class="docutils literal notranslate"><span class="pre">psa_hash_compare()</span></code>, the core calls the driver’s <code class="docutils literal notranslate"><span class="pre">&quot;hash_compute&quot;</span></code> entry point and compares the result with the reference hash value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;mac_compute&quot;</span></code>: calculation of a MAC.
Called by <code class="docutils literal notranslate"><span class="pre">psa_mac_compute()</span></code> and possibly <code class="docutils literal notranslate"><span class="pre">psa_mac_verify()</span></code>.
To verify a mac with <code class="docutils literal notranslate"><span class="pre">psa_mac_verify()</span></code>, the core calls an applicable driver’s <code class="docutils literal notranslate"><span class="pre">&quot;mac_verify&quot;</span></code> entry point if there is one, otherwise the core calls an applicable driver’s <code class="docutils literal notranslate"><span class="pre">&quot;mac_compute&quot;</span></code> entry point and compares the result with the reference MAC value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;mac_verify&quot;</span></code>: verification of a MAC.
Called by <code class="docutils literal notranslate"><span class="pre">psa_mac_verify()</span></code>.
This entry point is mainly useful for drivers of secure elements that verify a MAC without revealing the correct MAC.
Although transparent drivers may implement this entry point in addition to <code class="docutils literal notranslate"><span class="pre">&quot;mac_compute&quot;</span></code>, it is generally not useful because the core can call the <code class="docutils literal notranslate"><span class="pre">&quot;mac_compute&quot;</span></code> entry point and compare with the expected MAC value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;cipher_encrypt&quot;</span></code>: unauthenticated symmetric cipher encryption.
Called by <code class="docutils literal notranslate"><span class="pre">psa_cipher_encrypt()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;cipher_decrypt&quot;</span></code>: unauthenticated symmetric cipher decryption.
Called by <code class="docutils literal notranslate"><span class="pre">psa_cipher_decrypt()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;aead_encrypt&quot;</span></code>: authenticated encryption with associated data.
Called by <code class="docutils literal notranslate"><span class="pre">psa_aead_encrypt()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;aead_decrypt&quot;</span></code>: authenticated decryption with associated data.
Called by <code class="docutils literal notranslate"><span class="pre">psa_aead_decrypt()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;asymmetric_encrypt&quot;</span></code>: asymmetric encryption.
Called by <code class="docutils literal notranslate"><span class="pre">psa_asymmetric_encrypt()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;asymmetric_decrypt&quot;</span></code>: asymmetric decryption.
Called by <code class="docutils literal notranslate"><span class="pre">psa_asymmetric_decrypt()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;sign_hash&quot;</span></code>: signature of an already calculated hash.
Called by <code class="docutils literal notranslate"><span class="pre">psa_sign_hash()</span></code> and possibly <code class="docutils literal notranslate"><span class="pre">psa_sign_message()</span></code>.
To sign a message with <code class="docutils literal notranslate"><span class="pre">psa_sign_message()</span></code>, the core calls an applicable driver’s <code class="docutils literal notranslate"><span class="pre">&quot;sign_message&quot;</span></code> entry point if there is one, otherwise the core calls an applicable driver’s <code class="docutils literal notranslate"><span class="pre">&quot;hash_compute&quot;</span></code> entry point followed by an applicable driver’s <code class="docutils literal notranslate"><span class="pre">&quot;sign_hash&quot;</span></code> entry point.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;verify_hash&quot;</span></code>: verification of an already calculated hash.
Called by <code class="docutils literal notranslate"><span class="pre">psa_verify_hash()</span></code> and possibly <code class="docutils literal notranslate"><span class="pre">psa_verify_message()</span></code>.
To verify a message with <code class="docutils literal notranslate"><span class="pre">psa_verify_message()</span></code>, the core calls an applicable driver’s <code class="docutils literal notranslate"><span class="pre">&quot;verify_message&quot;</span></code> entry point if there is one, otherwise the core calls an applicable driver’s <code class="docutils literal notranslate"><span class="pre">&quot;hash_compute&quot;</span></code> entry point followed by an applicable driver’s <code class="docutils literal notranslate"><span class="pre">&quot;verify_hash&quot;</span></code> entry point.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;sign_message&quot;</span></code>: signature of a message.
Called by <code class="docutils literal notranslate"><span class="pre">psa_sign_message()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;verify_message&quot;</span></code>: verification of a message.
Called by <code class="docutils literal notranslate"><span class="pre">psa_verify_message()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;key_agreement&quot;</span></code>: key agreement without a subsequent key derivation.
Called by <code class="docutils literal notranslate"><span class="pre">psa_raw_key_agreement()</span></code> and possibly <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_key_agreement()</span></code>.</p></li>
</ul>
</section>
<section id="driver-entry-points-for-multi-part-operations">
<h2><span class="section-number">4.3 </span>Driver entry points for multi-part operations<a class="headerlink" href="#driver-entry-points-for-multi-part-operations" title="Link to this heading">¶</a></h2>
<section id="general-considerations-on-multi-part-operations">
<h3><span class="section-number">4.3.1 </span>General considerations on multi-part operations<a class="headerlink" href="#general-considerations-on-multi-part-operations" title="Link to this heading">¶</a></h3>
<p>The entry points that implement each step of a multi-part operation are grouped into a family.
A driver that implements a multi-part operation must define all of the entry points in this family as well as a type that represents the operation context.
The lifecycle of a driver operation context is similar to the lifecycle of an API operation context:</p>
<ol class="arabic simple">
<li><p>The core initializes operation context objects to either all-bits-zero or to logical zero (<code class="docutils literal notranslate"><span class="pre">{0}</span></code>), at its discretion.</p></li>
<li><p>The core calls the <code class="docutils literal notranslate"><span class="pre">xxx_setup</span></code> entry point for this operation family.
If this fails, the core destroys the operation context object without calling any other driver entry point on it.</p></li>
<li><p>The core calls other entry points that manipulate the operation context object, respecting the constraints.</p></li>
<li><p>If any entry point fails, the core calls the driver’s <code class="docutils literal notranslate"><span class="pre">xxx_abort</span></code> entry point for this operation family, then destroys the operation context object without calling any other driver entry point on it.</p></li>
<li><p>If a “finish” entry point fails, the core destroys the operation context object without calling any other driver entry point on it.
The finish entry points are: <em>prefix</em><code class="docutils literal notranslate"><span class="pre">_mac_sign_finish</span></code>, <em>prefix</em><code class="docutils literal notranslate"><span class="pre">_mac_verify_finish</span></code>, <em>prefix</em><code class="docutils literal notranslate"><span class="pre">_cipher_finish</span></code>, <em>prefix</em><code class="docutils literal notranslate"><span class="pre">_aead_finish</span></code>, <em>prefix</em><code class="docutils literal notranslate"><span class="pre">_aead_verify</span></code>.</p></li>
</ol>
<p>If a driver implements a multi-part operation but not the corresponding single-part operation, the core calls the driver’s multipart operation entry points to perform the single-part operation.</p>
</section>
<section id="multi-part-operation-entry-point-family-hash-multipart">
<h3><span class="section-number">4.3.2 </span>Multi-part operation entry point family <code class="docutils literal notranslate"><span class="pre">&quot;hash_multipart&quot;</span></code><a class="headerlink" href="#multi-part-operation-entry-point-family-hash-multipart" title="Link to this heading">¶</a></h3>
<p>This family corresponds to the calculation of a hash in multiple steps.</p>
<p>This family applies to transparent drivers only.</p>
<p>This family requires the following type and entry points:</p>
<ul class="simple">
<li><p>Type <code class="docutils literal notranslate"><span class="pre">&quot;hash_operation_t&quot;</span></code>: the type of a hash operation context.
It must be possible to copy a hash operation context byte by byte, therefore hash operation contexts must not contain any embedded pointers (except pointers to global data that do not change after the setup step).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;hash_setup&quot;</span></code>: called by <code class="docutils literal notranslate"><span class="pre">psa_hash_setup()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;hash_update&quot;</span></code>: called by <code class="docutils literal notranslate"><span class="pre">psa_hash_update()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;hash_finish&quot;</span></code>: called by <code class="docutils literal notranslate"><span class="pre">psa_hash_finish()</span></code> and <code class="docutils literal notranslate"><span class="pre">psa_hash_verify()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;hash_abort&quot;</span></code>: called by all multi-part hash functions of the Crypto API.</p></li>
</ul>
<p>To verify a hash with <code class="docutils literal notranslate"><span class="pre">psa_hash_verify()</span></code>, the core calls the driver’s <em>prefix</em><code class="docutils literal notranslate"><span class="pre">_hash_finish</span></code> entry point and compares the result with the reference hash value.</p>
<p>For example, a driver with the prefix <code class="docutils literal notranslate"><span class="pre">&quot;acme&quot;</span></code> that implements the <code class="docutils literal notranslate"><span class="pre">&quot;hash_multipart&quot;</span></code> entry point family must define the following type and entry points (assuming that the capability does not use the <code class="docutils literal notranslate"><span class="pre">&quot;names&quot;</span></code> property to declare different type and entry point names):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef ... acme_hash_operation_t;
psa_status_t acme_hash_setup(acme_hash_operation_t *operation,
                             psa_algorithm_t alg);
psa_status_t acme_hash_update(acme_hash_operation_t *operation,
                              const uint8_t *input,
                              size_t input_length);
psa_status_t acme_hash_finish(acme_hash_operation_t *operation,
                              uint8_t *hash,
                              size_t hash_size,
                              size_t *hash_length);
psa_status_t acme_hash_abort(acme_hash_operation_t *operation);
</pre></div>
</div>
</section>
<section id="operation-family-mac-multipart">
<h3><span class="section-number">4.3.3 </span>Operation family <code class="docutils literal notranslate"><span class="pre">&quot;mac_multipart&quot;</span></code><a class="headerlink" href="#operation-family-mac-multipart" title="Link to this heading">¶</a></h3>
<p>TODO</p>
</section>
<section id="operation-family-mac-verify-multipart">
<h3><span class="section-number">4.3.4 </span>Operation family <code class="docutils literal notranslate"><span class="pre">&quot;mac_verify_multipart&quot;</span></code><a class="headerlink" href="#operation-family-mac-verify-multipart" title="Link to this heading">¶</a></h3>
<p>TODO</p>
</section>
<section id="operation-family-cipher-encrypt-multipart">
<h3><span class="section-number">4.3.5 </span>Operation family <code class="docutils literal notranslate"><span class="pre">&quot;cipher_encrypt_multipart&quot;</span></code><a class="headerlink" href="#operation-family-cipher-encrypt-multipart" title="Link to this heading">¶</a></h3>
<p>TODO</p>
</section>
<section id="operation-family-cipher-decrypt-multipart">
<h3><span class="section-number">4.3.6 </span>Operation family <code class="docutils literal notranslate"><span class="pre">&quot;cipher_decrypt_multipart&quot;</span></code><a class="headerlink" href="#operation-family-cipher-decrypt-multipart" title="Link to this heading">¶</a></h3>
<p>TODO</p>
</section>
<section id="operation-family-aead-encrypt-multipart">
<h3><span class="section-number">4.3.7 </span>Operation family <code class="docutils literal notranslate"><span class="pre">&quot;aead_encrypt_multipart&quot;</span></code><a class="headerlink" href="#operation-family-aead-encrypt-multipart" title="Link to this heading">¶</a></h3>
<p>TODO</p>
</section>
<section id="operation-family-aead-decrypt-multipart">
<h3><span class="section-number">4.3.8 </span>Operation family <code class="docutils literal notranslate"><span class="pre">&quot;aead_decrypt_multipart&quot;</span></code><a class="headerlink" href="#operation-family-aead-decrypt-multipart" title="Link to this heading">¶</a></h3>
<p>TODO</p>
</section>
</section>
<section id="driver-entry-points-for-key-derivation">
<h2><span class="section-number">4.4 </span>Driver entry points for key derivation<a class="headerlink" href="#driver-entry-points-for-key-derivation" title="Link to this heading">¶</a></h2>
<p>Key derivation is more complex than other multipart operations for several reasons:</p>
<ul class="simple">
<li><p>There are multiple inputs and outputs.</p></li>
<li><p>Multiple drivers can be involved.
This happens when an operation combines a key agreement and a subsequent symmetric key derivation, each of which can have independent drivers.
This also happens when deriving an asymmetric key, where processing the secret input and generating the key output might involve different drivers.</p></li>
<li><p>When multiple drivers are involved, they are not always independent: if the secret input is managed by an opaque driver, it might not allow the core to retrieve the intermediate output and pass it to another driver.</p></li>
<li><p>The involvement of an opaque driver cannot be determined as soon as the operation is set up (since <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_setup()</span></code> does not determine the key input).</p></li>
</ul>
<section id="key-derivation-driver-dispatch-logic">
<span id="id2"></span><h3><span class="section-number">4.4.1 </span>Key derivation driver dispatch logic<a class="headerlink" href="#key-derivation-driver-dispatch-logic" title="Link to this heading">¶</a></h3>
<p>The core decides whether to dispatch a key derivation operation to a driver based on the location associated with the input step <code class="docutils literal notranslate"><span class="pre">PSA_KEY_DERIVATION_INPUT_SECRET</span></code>.</p>
<ol class="arabic simple">
<li><p>If this step is passed via <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_input_key()</span></code> for a key in a secure element:</p>
<ul class="simple">
<li><p>If the driver for this secure element implements the <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation&quot;</span></code> family for the specified algorithm, the core calls that driver’s <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_setup&quot;</span></code> and subsequent entry points.
Note that for all currently specified algorithms, the key type for the secret input does not matter.</p></li>
<li><p>Otherwise the core calls the secure element driver’s <a class="reference internal" href="opaque.html#key-management-with-opaque-drivers"><span class="std std-ref">&quot;export_key&quot;</span></a> entry point.</p></li>
</ul>
</li>
<li><p>Otherwise (<a class="reference internal" href="../appendix/open-issues.html#fallback-for-key-derivation-in-opaque-drivers"><span class="std std-ref">or on fallback?</span></a>), if there is a transparent driver for the specified algorithm, the core calls that driver’s <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_setup&quot;</span></code> and subsequent entry points.</p></li>
<li><p>Otherwise, or on fallback, the core uses its built-in implementation.</p></li>
</ol>
</section>
<section id="summary-of-entry-points-for-the-operation-family-key-derivation">
<h3><span class="section-number">4.4.2 </span>Summary of entry points for the operation family <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation&quot;</span></code><a class="headerlink" href="#summary-of-entry-points-for-the-operation-family-key-derivation" title="Link to this heading">¶</a></h3>
<p>A key derivation driver has the following entry points:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_setup&quot;</span></code> (mandatory): always the first entry point to be called.
This entry point provides the <a class="reference internal" href="#key-derivation-driver-initial-inputs"><span class="std std-ref">initial inputs</span></a>.
See <a class="reference internal" href="#key-derivation-driver-setup"><span class="secref">Key derivation driver setup</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_input_step&quot;</span></code> (mandatory if the driver supports a key derivation algorithm with long inputs, otherwise ignored): provide an extra input for the key derivation.
This entry point is only mandatory in drivers that support algorithms that have extra inputs.
See <a class="reference internal" href="#key-derivation-driver-long-inputs"><span class="secref">Key derivation driver long inputs</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_output_bytes&quot;</span></code> (mandatory): derive cryptographic material and output it.
See <a class="reference internal" href="#key-derivation-driver-outputs"><span class="secref">Key derivation driver outputs</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_output_key&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_verify_bytes&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_verify_key&quot;</span></code> (optional, opaque drivers only): derive key material which remains inside the same secure element.
See <a class="reference internal" href="#key-derivation-driver-outputs"><span class="secref">Key derivation driver outputs</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_set_capacity&quot;</span></code> (mandatory for opaque drivers that implement <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_output_key&quot;</span></code> for “cooked”, i.e. non-raw-data key types; ignored for other opaque drivers; not permitted for transparent drivers): update the capacity policy on the operation.
See <a class="reference internal" href="#key-derivation-driver-operation-capacity"><span class="secref">Key derivation driver operation capacity</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_abort&quot;</span></code> (mandatory): always the last entry point to be called.</p></li>
</ul>
<p>For naming purposes, here and in the following subsection, this specification takes the example of a driver with the prefix <code class="docutils literal notranslate"><span class="pre">&quot;acme&quot;</span></code> that implements the <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation&quot;</span></code> entry point family with a capability that does not use the <code class="docutils literal notranslate"><span class="pre">&quot;names&quot;</span></code> property to declare different type and entry point names.
Such a driver must implement the following type and functions, as well as the entry points listed above and described in the following subsections:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef ... acme_key_derivation_operation_t;
psa_status_t acme_key_derivation_abort(acme_key_derivation_operation_t *operation);
</pre></div>
</div>
</section>
<section id="key-derivation-driver-initial-inputs">
<span id="id3"></span><h3><span class="section-number">4.4.3 </span>Key derivation driver initial inputs<a class="headerlink" href="#key-derivation-driver-initial-inputs" title="Link to this heading">¶</a></h3>
<p>The core conveys the initial inputs for a key derivation via an opaque data structure of type <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_inputs_t</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef ... psa_crypto_driver_key_derivation_inputs_t; // implementation-specific type
</pre></div>
</div>
<p>A driver receiving an argument that points to a <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_inputs_t</span></code> can retrieve its contents by calling one of the type-specific functions below.
To determine the correct function, the driver can call <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_type()</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum psa_crypto_driver_key_derivation_input_type_t {
    PSA_KEY_DERIVATION_INPUT_TYPE_INVALID = 0,
    PSA_KEY_DERIVATION_INPUT_TYPE_OMITTED,
    PSA_KEY_DERIVATION_INPUT_TYPE_BYTES,
    PSA_KEY_DERIVATION_INPUT_TYPE_KEY,
    PSA_KEY_DERIVATION_INPUT_TYPE_INTEGER,
    // Implementations may add other values, and may freely choose the
    // numerical values for each identifer except as explicitly specified
    // above.
};
psa_crypto_driver_key_derivation_input_type_t psa_crypto_driver_key_derivation_get_input_type(
    const psa_crypto_driver_key_derivation_inputs_t *inputs,
    psa_key_derivation_step_t step);
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_type()</span></code> determines whether a given step is present and how to access its value:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_KEY_DERIVATION_INPUT_TYPE_INVALID</span></code>: the step is invalid for the algorithm of the operation that the inputs are for.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_KEY_DERIVATION_INPUT_TYPE_OMITTED</span></code>: the step is optional for the algorithm of the operation that the inputs are for, and has been omitted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_KEY_DERIVATION_INPUT_TYPE_BYTES</span></code>: the step is valid and present and is a transparent byte string.
Call <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_size()</span></code> to obtain the size of the input data.
Call <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_bytes()</span></code> to make a copy of the input data (design note: <a class="reference internal" href="../appendix/open-issues.html#key-derivation-inputs-and-buffer-ownership"><span class="std std-ref">why a copy?</span></a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_KEY_DERIVATION_INPUT_TYPE_KEY</span></code>: the step is valid and present and is a byte string passed via a key object.
Call <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_key()</span></code> to obtain a pointer to the key context.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_KEY_DERIVATION_INPUT_TYPE_INTEGER</span></code>: the step is valid and present and is an integer.
Call <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_integer()</span></code> to retrieve the integer value.</p></li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t psa_crypto_driver_key_derivation_get_input_size(
    const psa_crypto_driver_key_derivation_inputs_t *inputs,
    psa_key_derivation_step_t step,
    size_t *size);
psa_status_t psa_crypto_driver_key_derivation_get_input_bytes(
    const psa_crypto_driver_key_derivation_inputs_t *inputs,
    psa_key_derivation_step_t step,
    uint8_t *buffer, size_t buffer_size, size_t *buffer_length);
psa_status_t psa_crypto_driver_key_derivation_get_input_key(
    const psa_crypto_driver_key_derivation_inputs_t *inputs,
    psa_key_derivation_step_t step,
    const psa_key_attributes_t *attributes,
    uint8_t** p_key_buffer, size_t *key_buffer_size);
psa_status_t psa_crypto_driver_key_derivation_get_input_integer(
    const psa_crypto_driver_key_derivation_inputs_t *inputs,
    psa_key_derivation_step_t step,
    uint64_t *value);
</pre></div>
</div>
<p>The get-data functions take the following parameters:</p>
<ul class="simple">
<li><p>The first parameter <code class="docutils literal notranslate"><span class="pre">inputs</span></code> must be a pointer passed by the core to a key derivation driver setup entry point which has not returned yet.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">step</span></code> parameter indicates the input step whose content the driver wants to retrieve.</p></li>
<li><p>On a successful invocation of <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_size</span></code>, the core sets <code class="docutils literal notranslate"><span class="pre">*size</span></code> to the size of the specified input in bytes.</p></li>
<li><p>On a successful invocation of <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_bytes</span></code>, the core fills the first <em>N</em> bytes of <code class="docutils literal notranslate"><span class="pre">buffer</span></code> with the specified input and sets <code class="docutils literal notranslate"><span class="pre">*buffer_length</span></code> to <em>N</em>, where <em>N</em> is the length of the input in bytes.
The value of <code class="docutils literal notranslate"><span class="pre">buffer_size</span></code> must be at least <em>N</em>, otherwise this function fails with the status <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_BUFFER_TOO_SMALL</span></code>.</p></li>
<li><p>On a successful invocation of <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_key</span></code>, the core sets <code class="docutils literal notranslate"><span class="pre">*key_buffer</span></code> to a pointer to a buffer containing the key context and <code class="docutils literal notranslate"><span class="pre">*key_buffer_size</span></code> to the size of the key context in bytes.
The key context buffer remains valid for the duration of the driver entry point.
If the driver needs to access the key context after the current entry point returns, it must make a copy of the key context.</p></li>
<li><p>On a successful invocation of <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_integer</span></code>, the core sets <code class="docutils literal notranslate"><span class="pre">*value</span></code> to the value of the specified input.</p></li>
</ul>
<p>These functions can return the following statuses:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_SUCCESS</span></code>: the call succeeded and the requested value has been copied to the output parameter (<code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">buffer</span></code>, <code class="docutils literal notranslate"><span class="pre">value</span></code> or <code class="docutils literal notranslate"><span class="pre">p_key_buffer</span></code>) and if applicable the size of the value has been written to the applicable parameter (<code class="docutils literal notranslate"><span class="pre">buffer_length</span></code>, <code class="docutils literal notranslate"><span class="pre">key_buffer_size</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_ERROR_DOES_NOT_EXIST</span></code>: the input step is valid for this particular algorithm, but it is not part of the initial inputs.
This is not a fatal error.
The driver will receive the input later as a <a class="reference internal" href="#key-derivation-driver-long-inputs"><span class="std std-ref">long input</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_ERROR_INVALID_ARGUMENT</span></code>: the input type is not compatible with this function or was omitted.
Call <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_type()</span></code> to find out the actual type of this input step.
This is not a fatal error and the driver can, for example, subsequently call the appropriate function on the same step.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_ERROR_BUFFER_TOO_SMALL</span></code> (<code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_bytes</span></code> only): the output buffer is too small.
This is not a fatal error and the driver can, for example, subsequently call the same function again with a larger buffer.
Call <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_key_derivation_get_input_size</span></code> to obtain the required size.</p></li>
<li><p>The core may return other errors such as <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_CORRUPTION_DETECTED</span></code> or <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_COMMUNICATION_FAILURE</span></code> to convey implementation-specific error conditions.
Portable drivers should treat such conditions as fatal errors.</p></li>
</ul>
</section>
<section id="key-derivation-driver-setup">
<span id="id4"></span><h3><span class="section-number">4.4.4 </span>Key derivation driver setup<a class="headerlink" href="#key-derivation-driver-setup" title="Link to this heading">¶</a></h3>
<p>A key derivation driver must implement the following entry point:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_key_derivation_setup(
    acme_key_derivation_operation_t *operation,
    psa_algorithm_t alg,
    const psa_crypto_driver_key_derivation_inputs_t *inputs);
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">operation</span></code> is a zero-initialized operation object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alg</span></code> is the algorithm for the key derivation operation.
It does not include a key agreement component.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputs</span></code> is an opaque pointer to the <a class="reference internal" href="#key-derivation-driver-initial-inputs"><span class="std std-ref">initial inputs</span></a> for the key derivation.</p></li>
</ul>
</section>
<section id="key-derivation-driver-long-inputs">
<span id="id5"></span><h3><span class="section-number">4.4.5 </span>Key derivation driver long inputs<a class="headerlink" href="#key-derivation-driver-long-inputs" title="Link to this heading">¶</a></h3>
<p>Some key derivation algorithms take long inputs which it would not be practical to pass in the <a class="reference internal" href="#key-derivation-driver-initial-inputs"><span class="std std-ref">initial inputs</span></a>.
A driver that implements a key derivation algorithm that takes such inputs must provide a <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_input_step&quot;</span></code> entry point.
The core calls this entry point for all the long inputs after calling <code class="docutils literal notranslate"><span class="pre">&quot;acme_key_derivation_setup&quot;</span></code>.
A long input step may be fragmented into multiple calls of <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_input_bytes()</span></code>, and the core may reassemble or refragment those fragments before passing them to the driver.
Calls to this entry point for different step values occur in an unspecified order and may be interspersed.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_key_derivation_input_step(
    acme_key_derivation_operation_t *operation,
    psa_key_derivation_step_t step,
    const uint8_t *input, size_t input_length);
</pre></div>
</div>
<p>At the time of writing, no standard key derivation algorithm has long inputs.
It is likely that such algorithms will be added in the future.</p>
</section>
<section id="key-derivation-driver-operation-capacity">
<span id="id6"></span><h3><span class="section-number">4.4.6 </span>Key derivation driver operation capacity<a class="headerlink" href="#key-derivation-driver-operation-capacity" title="Link to this heading">¶</a></h3>
<p>The core keeps track of an operation’s capacity and enforces it.
The core guarantees that it will not request output beyond the capacity of the operation, with one exception: opaque drivers that support <a class="reference internal" href="#key-derivation-driver-outputs"><span class="std std-ref">&quot;key_derivation_output_key&quot;</span></a>, i.e. for key types where the derived key material is not a direct copy of the key derivation’s output stream.</p>
<p>Such drivers must enforce the capacity limitation and must return <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_INSUFFICIENT_CAPACITY</span></code> from any output request that exceeds the operation’s capacity.
Such drivers must provide the following entry point:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_key_derivation_set_capacity(
    acme_key_derivation_operation_t *operation,
    size_t capacity);
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">capacity</span></code> is guaranteed to be less or equal to any value previously set through this entry point, and is guaranteed not to be <code class="docutils literal notranslate"><span class="pre">PSA_KEY_DERIVATION_UNLIMITED_CAPACITY</span></code>.</p>
<p>If this entry point has not been called, the operation has an unlimited capacity.</p>
</section>
<section id="key-derivation-driver-outputs">
<span id="id7"></span><h3><span class="section-number">4.4.7 </span>Key derivation driver outputs<a class="headerlink" href="#key-derivation-driver-outputs" title="Link to this heading">¶</a></h3>
<p>A key derivation driver must provide the following entry point:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_key_derivation_output_bytes(
    acme_key_derivation_operation_t *operation,
    uint8_t *output, size_t length);
</pre></div>
</div>
<p>An opaque key derivation driver may provide the following entry points:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_key_derivation_output_key(
    const psa_key_attributes_t *attributes,
    acme_key_derivation_operation_t *operation,
    uint8_t *key_buffer, size_t key_buffer_size, size_t *key_buffer_length);
psa_status_t acme_key_derivation_verify_bytes(
    acme_key_derivation_operation_t *operation,
    const uint8_t *expected output, size_t length);
psa_status_t acme_key_derivation_verify_key(
    acme_key_derivation_operation_t *operation,
    uint8_t *key_buffer, size_t key_buffer_size);
</pre></div>
</div>
<p>The core calls a key derivation driver’s output entry point when the application calls <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_output_bytes()</span></code>, <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_output_key()</span></code>, <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_verify_bytes()</span></code> or <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_verify_key()</span></code>.</p>
<p>If the key derivation’s <code class="docutils literal notranslate"><span class="pre">PSA_KEY_DERIVATION_INPUT_SECRET</span></code> input is in a secure element and the derivation operation is handled by that secure element, the core performs the following steps:</p>
<ul class="simple">
<li><p>For a call to <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_output_key()</span></code>:</p>
<ol class="arabic simple">
<li><p>If the derived key is in the same secure element, if the driver has an <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_output_key&quot;</span></code> entry point, call that entry point.
If the driver has no such entry point, or if that entry point returns <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_NOT_SUPPORTED</span></code>, continue with the following steps, otherwise stop.</p></li>
<li><p>If the driver’s capabilities indicate that its <code class="docutils literal notranslate"><span class="pre">&quot;import_key&quot;</span></code> entry point does not support the derived key, stop and return <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_NOT_SUPPORTED</span></code>.</p></li>
<li><p>Otherwise proceed as for <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_output_bytes()</span></code>, then import the resulting key material.</p></li>
</ol>
</li>
<li><p>For a call to <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_verify_key()</span></code>:</p>
<ol class="arabic simple">
<li><p>If the driver has a <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_verify_key&quot;</span></code> entry point, call it and stop.</p></li>
<li><p>Call the driver’s <code class="docutils literal notranslate"><span class="pre">&quot;export_key&quot;</span></code> entry point on the key object that contains the expected value, then proceed as for <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_verify_bytes()</span></code>.</p></li>
</ol>
</li>
<li><p>For a call to <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_verify_bytes()</span></code>:</p>
<ol class="arabic simple">
<li><p>If the driver has a <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_verify_bytes&quot;</span></code> entry point, call that entry point on the expected output, then stop.</p></li>
<li><p>Otherwise, proceed as for <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_output_bytes()</span></code>, and compare the resulting output to the expected output inside the core.</p></li>
</ol>
</li>
<li><p>For a call to <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_output_bytes()</span></code>:</p>
<ol class="arabic simple">
<li><p>Call the <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_output_bytes&quot;</span></code> entry point.
The core may call this entry point multiple times to implement a single call from the application when deriving a cooked (non-raw) key as described below, or if the output size exceeds some implementation limit.</p></li>
</ol>
</li>
</ul>
<p>If the key derivation operation is not handled by an opaque driver as described above, the core calls the <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_output_bytes&quot;</span></code> from the applicable transparent driver (or multiple drivers in succession if fallback applies).
In some cases, the core then calls additional entry points in the same or another driver:</p>
<ul class="simple">
<li><p>For a call to <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_output_key()</span></code> for some key types, the core calls a transparent driver’s <code class="docutils literal notranslate"><span class="pre">&quot;derive_key&quot;</span></code> entry point.
See <a class="reference internal" href="#transparent-cooked-key-derivation"><span class="secref">Transparent cooked key derivation</span></a>.</p></li>
<li><p>For a call to <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_output_key()</span></code> where the derived key is in a secure element, call that secure element driver’s <code class="docutils literal notranslate"><span class="pre">&quot;import_key&quot;</span></code> entry point.</p></li>
</ul>
</section>
<section id="transparent-cooked-key-derivation">
<span id="id8"></span><h3><span class="section-number">4.4.8 </span>Transparent cooked key derivation<a class="headerlink" href="#transparent-cooked-key-derivation" title="Link to this heading">¶</a></h3>
<p>Key derivation is said to be <em>raw</em> for some key types, where the key material of a derived (8<em>n</em>)-bit key consists of the next <em>n</em> bytes of output from the key derivation, and <em>cooked</em> otherwise.
When deriving a raw key, the core only calls the driver’s <code class="docutils literal notranslate"><span class="pre">&quot;output_bytes&quot;</span></code> entry point, except when deriving a key entirely inside a secure element as described in <a class="reference internal" href="#key-derivation-driver-outputs"><span class="secref">Key derivation driver outputs</span></a>.
When deriving a cooked key, the core calls a transparent driver’s <code class="docutils literal notranslate"><span class="pre">&quot;derive_key&quot;</span></code> entry point if available.</p>
<p>A capability for cooked key derivation contains the following properties (this is not a subset of <a class="reference internal" href="manifest.html#capability-syntax"><span class="std std-ref">the usual entry point properties</span></a>):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;entry_points&quot;</span></code> (mandatory, list of strings).
Must be <code class="docutils literal notranslate"><span class="pre">[&quot;derive_key&quot;]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;derived_types&quot;</span></code> (mandatory, list of strings).
Each element is a <a class="reference internal" href="manifest.html#key-type-specifications"><span class="std std-ref">key type specification</span></a>.
This capability only applies when deriving a key of the specified type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;derived_sizes&quot;</span></code> (optional, list of integers).
Each element is a size for the derived key, in bits.
This capability only applies when deriving a key of the specified sizes.
If absent, this capability applies to all sizes for the specified types.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;memory&quot;</span></code> (optional, boolean).
If present and true, the driver must define a type <code class="docutils literal notranslate"><span class="pre">&quot;derive_key_memory_t&quot;</span></code> and the core will allocate an object of that type as specified below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;names&quot;</span></code> (optional, object).
A mapping from entry point names to C function and type names, as usual.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;fallback&quot;</span></code> (optional, boolean).
If present and true, the driver may return <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_NOT_SUPPORTED</span></code> if it only partially supports the specified mechanism, as usual.</p></li>
</ul>
<p>A transparent driver with the prefix <code class="docutils literal notranslate"><span class="pre">&quot;acme&quot;</span></code> that implements cooked key derivation must provide the following type and function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef ... acme_derive_key_memory_t; // only if the &quot;memory&quot; property is true
psa_status_t acme_derive_key(
    const psa_key_attributes_t *attributes,
    const uint8_t *input, size_t input_length,
    acme_derive_key_memory_t *memory, // if the &quot;memory&quot; property is false: void*
    uint8_t *key_buffer, size_t key_buffer_size, size_t *key_buffer_length);
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">attributes</span></code> contains the attributes of the specified key.
Note that only the key type and the bit-size are guaranteed to be set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">input</span></code> is a buffer of <code class="docutils literal notranslate"><span class="pre">input_length</span></code> bytes which contains the raw key stream, i.e. the data that <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_output_bytes()</span></code> would return.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">&quot;memory&quot;</span></code> property in the driver capability is true, <code class="docutils literal notranslate"><span class="pre">memory</span></code> is a data structure that the driver may use to store data between successive calls of the <code class="docutils literal notranslate"><span class="pre">&quot;derive_key&quot;</span></code> entry point to derive the same key.
If the <code class="docutils literal notranslate"><span class="pre">&quot;memory&quot;</span></code> property is false or absent, the <code class="docutils literal notranslate"><span class="pre">memory</span></code> parameter is a null pointer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">key_buffer</span></code> is a buffer for the output material, in the appropriate <a class="reference internal" href="transparent.html#key-format-for-transparent-drivers"><span class="std std-ref">export format</span></a> for the key type.
Its size is <code class="docutils literal notranslate"><span class="pre">key_buffer_size</span></code> bytes.</p></li>
<li><p>On success, <code class="docutils literal notranslate"><span class="pre">*key_buffer_length</span></code> must contain the number of bytes written to <code class="docutils literal notranslate"><span class="pre">key_buffer</span></code>.</p></li>
</ul>
<p>This entry point may return the following statuses:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_SUCCESS</span></code>: a key was derived successfully.
The driver has placed the representation of the key in <code class="docutils literal notranslate"><span class="pre">key_buffer</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_ERROR_NOT_SUPPORTED</span></code> (for the first call only) (only if fallback is enabled): the driver cannot fulfill this request, but a fallback driver might.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_ERROR_INSUFFICIENT_DATA</span></code>: the core must call the <code class="docutils literal notranslate"><span class="pre">&quot;derive_key&quot;</span></code> entry point again with the same <code class="docutils literal notranslate"><span class="pre">memory</span></code> object and with subsequent data from the key stream.</p></li>
<li><p>Any other error is a fatal error.</p></li>
</ul>
<p>The core calls the <code class="docutils literal notranslate"><span class="pre">&quot;derive_key&quot;</span></code> entry point in a loop until it returns a status other than <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_INSUFFICIENT_DATA</span></code>.
Each call has a successive fragment of the key stream.
The <code class="docutils literal notranslate"><span class="pre">memory</span></code> object is guaranteed to be the same for successive calls, but note that its address may change between calls.
Before the first call, <code class="docutils literal notranslate"><span class="pre">*memory</span></code> is initialized to all-bits-zero.</p>
<p>For standard key types, the <code class="docutils literal notranslate"><span class="pre">&quot;derive_key&quot;</span></code> entry point is called with a certain input length as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_DES</span></code>: the length of the key.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_ECC_KEY_PAIR(…)</span></code>, <code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_DH_KEY_PAIR(…)</span></code>: <em>m</em> bytes, where the bit-size of the key <em>n</em> satisfies 8(<em>m</em>-1) &lt; <em>n</em> &lt;= 8<em>m</em>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_RSA_KEY_PAIR</span></code>: an implementation-defined length.
A future version of this specification may specify a length.</p></li>
<li><p>Other key types: not applicable.</p></li>
</ul>
<p>See <a class="reference internal" href="../appendix/open-issues.html#cooked-key-derivation-issue"><span class="secref">Open questions around cooked key derivation</span></a> for some points that may not be fully settled.</p>
</section>
<section id="key-agreement">
<span id="id9"></span><h3><span class="section-number">4.4.9 </span>Key agreement<a class="headerlink" href="#key-agreement" title="Link to this heading">¶</a></h3>
<p>The core always decouples key agreement from symmetric key derivation.</p>
<p>To implement a call to <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_key_agreement()</span></code> where the private key is in a secure element that has a <code class="docutils literal notranslate"><span class="pre">&quot;key_agreement_to_key&quot;</span></code> entry point which is applicable for the given key type and algorithm, the core calls the secure element driver as follows:</p>
<ol class="arabic simple">
<li><p>Call the <code class="docutils literal notranslate"><span class="pre">&quot;key_agreement_to_key&quot;</span></code> entry point to create a key object containing the shared secret.
The key object is volatile and has the type <code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_DERIVE</span></code>.</p></li>
<li><p>Call the <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_setup&quot;</span></code> entry point, passing the resulting key object .</p></li>
<li><p>Perform the rest of the key derivation, up to and including the call to the <code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_abort&quot;</span></code> entry point.</p></li>
<li><p>Call the <code class="docutils literal notranslate"><span class="pre">&quot;destroy_key&quot;</span></code> entry point to destroy the key containing the key object.</p></li>
</ol>
<p>In other cases, the core treats <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_key_agreement()</span></code> as if it was a call to <code class="docutils literal notranslate"><span class="pre">psa_raw_key_agreement()</span></code> followed by a call to <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_input_bytes()</span></code> on the shared secret.</p>
<p>The entry points related to key agreement have the following prototypes for a driver with the prefix <code class="docutils literal notranslate"><span class="pre">&quot;acme&quot;</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_key_agreement(psa_algorithm_t alg,
                                const psa_key_attributes_t *our_attributes,
                                const uint8_t *our_key_buffer,
                                size_t our_key_buffer_length,
                                const uint8_t *peer_key,
                                size_t peer_key_length,
                                uint8_t *output,
                                size_t output_size,
                                size_t *output_length);
psa_status_t acme_key_agreement_to_key(psa_algorithm_t alg,
                                       const psa_key_attributes_t *our_attributes,
                                       const uint8_t *our_key_buffer,
                                       size_t our_key_buffer_length,
                                       const uint8_t *peer_key,
                                       size_t peer_key_length,
                                       const psa_key_attributes_t *shared_secret_attributes,
                                       uint8_t *shared_secret_key_buffer,
                                       size_t shared_secret_key_buffer_size,
                                       size_t *shared_secret_key_buffer_length);
</pre></div>
</div>
<p>Note that unlike most other key creation entry points, in <code class="docutils literal notranslate"><span class="pre">&quot;acme_key_agreement_to_key&quot;</span></code>, the attributes for the shared secret are not placed near the beginning, but rather grouped with the other parameters related to the shared secret at the end of the parameter list.
This is to avoid potential confusion with the attributes of the private key that is passed as an input.</p>
</section>
</section>
<section id="driver-entry-points-for-pake">
<h2><span class="section-number">4.5 </span>Driver entry points for PAKE<a class="headerlink" href="#driver-entry-points-for-pake" title="Link to this heading">¶</a></h2>
<p>A PAKE operation is divided into two stages: collecting inputs and computation.
Core side is responsible for keeping inputs and core set-data functions do not have driver entry points.
Collected inputs are available for drivers via get-data functions for <code class="docutils literal notranslate"><span class="pre">password</span></code>, <code class="docutils literal notranslate"><span class="pre">role</span></code> and <code class="docutils literal notranslate"><span class="pre">cipher_suite</span></code>.</p>
<section id="pake-driver-dispatch-logic">
<h3><span class="section-number">4.5.1 </span>PAKE driver dispatch logic<a class="headerlink" href="#pake-driver-dispatch-logic" title="Link to this heading">¶</a></h3>
<p>The core decides whether to dispatch a PAKE operation to a driver based on the location of the provided password.
When all inputs are collected and <code class="docutils literal notranslate"><span class="pre">&quot;psa_pake_output&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;psa_pake_input&quot;</span></code> is called for the first time <code class="docutils literal notranslate"><span class="pre">&quot;pake_setup&quot;</span></code> driver entry point is invoked.</p>
<ol class="arabic simple">
<li><p>If the location of the <code class="docutils literal notranslate"><span class="pre">password</span></code> is the local storage</p>
<ul class="simple">
<li><p>if there is a transparent driver for the specified ciphersuite, the core calls that driver’s <code class="docutils literal notranslate"><span class="pre">&quot;pake_setup&quot;</span></code> and subsequent entry points.</p></li>
<li><p>otherwise, or on fallback, the core uses its built-in implementation.</p></li>
</ul>
</li>
<li><p>If the location of the <code class="docutils literal notranslate"><span class="pre">password</span></code> is the location of a secure element
-   the core calls the <code class="docutils literal notranslate"><span class="pre">&quot;pake_setup&quot;</span></code> entry point of the secure element driver and subsequent entry points.</p></li>
</ol>
</section>
<section id="summary-of-entry-points-for-pake">
<h3><span class="section-number">4.5.2 </span>Summary of entry points for PAKE<a class="headerlink" href="#summary-of-entry-points-for-pake" title="Link to this heading">¶</a></h3>
<p>A PAKE driver has the following entry points:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;pake_setup&quot;</span></code> (mandatory): always the first entry point to be called.
It is called when all inputs are collected and the computation stage starts.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;pake_output&quot;</span></code> (mandatory): derive cryptographic material for the specified step and output it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;pake_input&quot;</span></code> (mandatory): provides cryptographic material in the format appropriate for the specified step.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;pake_get_implicit_key&quot;</span></code> (mandatory): returns implicitly confirmed shared secret from a PAKE.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;pake_abort&quot;</span></code> (mandatory): always the last entry point to be called.</p></li>
</ul>
<p>For naming purposes, here and in the following subsection, this specification takes the example of a driver with the prefix <code class="docutils literal notranslate"><span class="pre">&quot;acme&quot;</span></code> that implements the PAKE entry point family with a capability that does not use the <code class="docutils literal notranslate"><span class="pre">&quot;names&quot;</span></code> property to declare different type and entry point names.
Such a driver must implement the following type and functions, as well as the entry points listed above and described in the following subsections:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef ... acme_pake_operation_t;
psa_status_t acme_pake_abort( acme_pake_operation_t *operation );
</pre></div>
</div>
</section>
<section id="pake-driver-inputs">
<span id="id10"></span><h3><span class="section-number">4.5.3 </span>PAKE driver inputs<a class="headerlink" href="#pake-driver-inputs" title="Link to this heading">¶</a></h3>
<p>The core conveys the initial inputs for a PAKE operation via an opaque data structure of type <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_pake_inputs_t</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef ... psa_crypto_driver_pake_inputs_t; // implementation-specific type
</pre></div>
</div>
<p>A driver receiving an argument that points to a <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_pake_inputs_t</span></code> can retrieve its contents by calling one of the get-data functions below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t psa_crypto_driver_pake_get_password_len(
    const psa_crypto_driver_pake_inputs_t *inputs,
    size_t *password_len);

psa_status_t psa_crypto_driver_pake_get_password_bytes(
    const psa_crypto_driver_pake_inputs_t *inputs,
    uint8_t *buffer, size_t buffer_size, size_t *buffer_length);

psa_status_t psa_crypto_driver_pake_get_password_key(
    const psa_crypto_driver_pake_inputs_t *inputs,
    uint8_t** p_key_buffer, size_t *key_buffer_size,
    const psa_key_attributes_t *attributes);

psa_status_t psa_crypto_driver_pake_get_user_len(
    const psa_crypto_driver_pake_inputs_t *inputs,
    size_t *user_len);

psa_status_t psa_crypto_driver_pake_get_user(
    const psa_crypto_driver_pake_inputs_t *inputs,
    uint8_t *user_id, size_t user_id_size, size_t *user_id_len);

psa_status_t psa_crypto_driver_pake_get_peer_len(
    const psa_crypto_driver_pake_inputs_t *inputs,
    size_t *peer_len);

psa_status_t psa_crypto_driver_pake_get_peer(
    const psa_crypto_driver_pake_inputs_t *inputs,
    uint8_t *peer_id, size_t peer_id_size, size_t *peer_id_length);

psa_status_t psa_crypto_driver_pake_get_cipher_suite(
    const psa_crypto_driver_pake_inputs_t *inputs,
    psa_pake_cipher_suite_t *cipher_suite);
</pre></div>
</div>
<p>The get-data functions take the following parameters:</p>
<p>The first parameter <code class="docutils literal notranslate"><span class="pre">inputs</span></code> must be a pointer passed by the core to a PAKE driver setup entry point.
Next parameters are return buffers (must not be null pointers).</p>
<p>These functions can return the following statuses:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_SUCCESS</span></code>: value has been successfully obtained</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_ERROR_BAD_STATE</span></code>: the inputs are not ready</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_ERROR_BUFFER_TOO_SMALL</span></code> (<code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_pake_get_password_bytes</span></code> and <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_pake_get_password_key</span></code> only): the output buffer is too small.
This is not a fatal error and the driver can, for example, subsequently call the same function again with a larger buffer.
Call <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_pake_get_password_len</span></code> to obtain the required size.</p></li>
</ul>
</section>
<section id="pake-driver-setup">
<h3><span class="section-number">4.5.4 </span>PAKE driver setup<a class="headerlink" href="#pake-driver-setup" title="Link to this heading">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_pake_setup( acme_pake_operation_t *operation,
                              const psa_crypto_driver_pake_inputs_t *inputs );
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">operation</span></code> is a zero-initialized operation object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputs</span></code> is an opaque pointer to the <a class="reference internal" href="#pake-driver-inputs"><span class="std std-ref">inputs</span></a> for the PAKE operation.</p></li>
</ul>
<p>The setup driver function should preserve the inputs using get-data functions.</p>
<p>The pointer output by <code class="docutils literal notranslate"><span class="pre">psa_crypto_driver_pake_get_password_key</span></code> is only valid until the “pake_setup” entry point returns.
Opaque drivers must copy all relevant data from the key buffer during the “pake_setup” entry point and must not store the pointer itself.</p>
</section>
<section id="pake-driver-output">
<h3><span class="section-number">4.5.5 </span>PAKE driver output<a class="headerlink" href="#pake-driver-output" title="Link to this heading">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_pake_output(acme_pake_operation_t *operation,
                              psa_crypto_driver_pake_step_t step,
                              uint8_t *output,
                              size_t output_size,
                              size_t *output_length);
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">operation</span></code> is an operation object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">step</span></code> computation step based on which driver should perform an action.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> buffer where the output is to be written.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output_size</span></code> size of the output buffer in bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output_length</span></code> the number of bytes of the returned output.</p></li>
</ul>
<p>For <code class="docutils literal notranslate"><span class="pre">PSA_ALG_JPAKE</span></code> the following steps are available for output operation:
<code class="docutils literal notranslate"><span class="pre">step</span></code> can be one of the following values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X1_STEP_KEY_SHARE</span></code>     Round 1: output our key share (for ephemeral private key X1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X1_STEP_ZK_PUBLIC</span></code>     Round 1: output Schnorr NIZKP public key for the X1 key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X1_STEP_ZK_PROOF</span></code>      Round 1: output Schnorr NIZKP proof for the X1 key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X2_STEP_KEY_SHARE</span></code>     Round 1: output our key share (for ephemeral private key X2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X2_STEP_ZK_PUBLIC</span></code>     Round 1: output Schnorr NIZKP public key for the X2 key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X2_STEP_ZK_PROOF</span></code>      Round 1: output Schnorr NIZKP proof for the X2 key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X2S_STEP_KEY_SHARE</span></code>    Round 2: output our X2S key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X2S_STEP_ZK_PUBLIC</span></code>    Round 2: output Schnorr NIZKP public key for the X2S key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X2S_STEP_ZK_PROOF</span></code>     Round 2: output Schnorr NIZKP proof for the X2S key</p></li>
</ul>
</section>
<section id="pake-driver-input">
<h3><span class="section-number">4.5.6 </span>PAKE driver input<a class="headerlink" href="#pake-driver-input" title="Link to this heading">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_pake_input(acme_pake_operation_t *operation,
                             psa_crypto_driver_pake_step_t step,
                             uint8_t *input,
                             size_t input_size);
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">operation</span></code> is an operation object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">step</span></code> computation step based on which driver should perform an action.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">input</span></code> buffer containing the input.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">input_length</span></code> length of the input in bytes.</p></li>
</ul>
<p>For <code class="docutils literal notranslate"><span class="pre">PSA_ALG_JPAKE</span></code> the following steps are available for input operation:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X1_STEP_KEY_SHARE</span></code>     Round 1: input key share from peer (for ephemeral private key X1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X1_STEP_ZK_PUBLIC</span></code>     Round 1: input Schnorr NIZKP public key for the X1 key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X1_STEP_ZK_PROOF</span></code>      Round 1: input Schnorr NIZKP proof for the X1 key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X2_STEP_KEY_SHARE</span></code>     Round 1: input key share from peer (for ephemeral private key X2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X2_STEP_ZK_PUBLIC</span></code>     Round 1: input Schnorr NIZKP public key for the X2 key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X2_STEP_ZK_PROOF</span></code>      Round 1: input Schnorr NIZKP proof for the X2 key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X4S_STEP_KEY_SHARE</span></code>    Round 2: input X4S key from peer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X4S_STEP_ZK_PUBLIC</span></code>    Round 2: input Schnorr NIZKP public key for the X4S key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_JPAKE_X4S_STEP_ZK_PROOF</span></code>     Round 2: input Schnorr NIZKP proof for the X4S key</p></li>
</ul>
<p>The core checks that <code class="docutils literal notranslate"><span class="pre">input_length</span></code> is not greater than <code class="docutils literal notranslate"><span class="pre">PSA_PAKE_INPUT_SIZE(alg,</span> <span class="pre">prim,</span> <span class="pre">step)</span></code> and
the driver can rely on that.</p>
</section>
<section id="pake-driver-get-implicit-key">
<h3><span class="section-number">4.5.7 </span>PAKE driver get implicit key<a class="headerlink" href="#pake-driver-get-implicit-key" title="Link to this heading">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_pake_get_implicit_key(
                            acme_pake_operation_t *operation,
                            uint8_t *output, size_t output_size,
                            size_t *output_length );
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">operation</span></code> The driver PAKE operation object to use.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> Buffer where the implicit key is to be written.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output_size</span></code> Size of the output buffer in bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output_length</span></code> On success, the number of bytes of the implicit key.</p></li>
</ul>
</section>
</section>
<section id="driver-entry-points-for-key-management">
<span id="id11"></span><h2><span class="section-number">4.6 </span>Driver entry points for key management<a class="headerlink" href="#driver-entry-points-for-key-management" title="Link to this heading">¶</a></h2>
<p>The driver entry points for key management differ significantly between <a class="reference internal" href="transparent.html#key-management-with-transparent-drivers"><span class="std std-ref">transparent drivers</span></a> and <a class="reference internal" href="opaque.html#key-management-with-opaque-drivers"><span class="std std-ref">opaque drivers</span></a>.
This section describes common elements.
Refer to the applicable section for each driver type for more information.</p>
<p>The entry points that create or format key data have the following prototypes for a driver with the prefix <code class="docutils literal notranslate"><span class="pre">&quot;acme&quot;</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_import_key(const psa_key_attributes_t *attributes,
                             const uint8_t *data,
                             size_t data_length,
                             uint8_t *key_buffer,
                             size_t key_buffer_size,
                             size_t *key_buffer_length,
                             size_t *bits); // additional parameter, see below
psa_status_t acme_generate_key(const psa_key_attributes_t *attributes,
                               uint8_t *key_buffer,
                               size_t key_buffer_size,
                               size_t *key_buffer_length);
</pre></div>
</div>
<p>Additionally, opaque drivers can create keys through their <a class="reference internal" href="#key-derivation-driver-outputs"><span class="std std-ref">&quot;key_derivation_output_key&quot;</span></a> and <a class="reference internal" href="#key-agreement"><span class="std std-ref">&quot;key_agreement_key&quot;</span></a> entry points.
Transparent drivers can create key material through their <a class="reference internal" href="#transparent-cooked-key-derivation"><span class="std std-ref">&quot;derive_key&quot;</span></a> entry point.</p>
<p>TODO: copy</p>
<ul class="simple">
<li><p>The key attributes (<code class="docutils literal notranslate"><span class="pre">attributes</span></code>) have the same semantics as in the Crypto API.</p></li>
<li><p>For the <code class="docutils literal notranslate"><span class="pre">&quot;import_key&quot;</span></code> entry point, the input in the <code class="docutils literal notranslate"><span class="pre">data</span></code> buffer is either the export format or an implementation-specific format that the core documents as an acceptable input format for <code class="docutils literal notranslate"><span class="pre">psa_import_key()</span></code>.</p></li>
<li><p>The size of the key data buffer <code class="docutils literal notranslate"><span class="pre">key_buffer</span></code> is sufficient for the internal representation of the key.
For a transparent driver, this is the key’s <a class="reference internal" href="transparent.html#key-format-for-transparent-drivers"><span class="std std-ref">export format</span></a>.
For an opaque driver, this is the size determined from the driver description and the key attributes, as specified in the section <a class="reference internal" href="opaque.html#key-format-for-opaque-drivers"><span class="secref">Key format for opaque drivers</span></a>.</p></li>
<li><p>For an opaque driver with an <code class="docutils literal notranslate"><span class="pre">&quot;allocate_key&quot;</span></code> entry point, the content of the key data buffer on entry is the output of that entry point.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">&quot;import_key&quot;</span></code> entry point must determine or validate the key size and set <code class="docutils literal notranslate"><span class="pre">*bits</span></code> as described in <a class="reference internal" href="#key-size-determination-on-import"><span class="secref">Key size determination on import</span></a>.</p></li>
</ul>
<p>All key creation entry points must ensure that the resulting key is valid as specified in <a class="reference internal" href="#key-validation"><span class="secref">Key validation</span></a>.
This is primarily important for import entry points since the key data comes from the application.</p>
<section id="key-size-determination-on-import">
<span id="id12"></span><h3><span class="section-number">4.6.1 </span>Key size determination on import<a class="headerlink" href="#key-size-determination-on-import" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;import_key&quot;</span></code> entry point must determine or validate the key size.
The Crypto API exposes the key size as part of the key attributes.
When importing a key, the key size recorded in the key attributes can be either a size specified by the caller of the API (who may not be trusted), or <code class="docutils literal notranslate"><span class="pre">0</span></code> which indicates that the size must be calculated from the data.</p>
<p>When the core calls the <code class="docutils literal notranslate"><span class="pre">&quot;import_key&quot;</span></code> entry point to process a call to <code class="docutils literal notranslate"><span class="pre">psa_import_key</span></code>, it passes an <code class="docutils literal notranslate"><span class="pre">attributes</span></code> structure such that <code class="docutils literal notranslate"><span class="pre">psa_get_key_bits(attributes)</span></code> is the size passed by the caller of <code class="docutils literal notranslate"><span class="pre">psa_import_key</span></code>.
If this size is <code class="docutils literal notranslate"><span class="pre">0</span></code>, the <code class="docutils literal notranslate"><span class="pre">&quot;import_key&quot;</span></code> entry point must set the <code class="docutils literal notranslate"><span class="pre">bits</span></code> input-output parameter to the correct key size.
The semantics of <code class="docutils literal notranslate"><span class="pre">bits</span></code> is as follows:</p>
<ul class="simple">
<li><p>The core sets <code class="docutils literal notranslate"><span class="pre">*bits</span></code> to <code class="docutils literal notranslate"><span class="pre">psa_get_key_bits(attributes)</span></code> before calling the <code class="docutils literal notranslate"><span class="pre">&quot;import_key&quot;</span></code> entry point.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">*bits</span> <span class="pre">==</span> <span class="pre">0</span></code>, the driver must determine the key size from the data and set <code class="docutils literal notranslate"><span class="pre">*bits</span></code> to this size.
If the key size cannot be determined from the data, the driver must return <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_INVALID_ARGUMENT</span></code> (as of version 1.0 of the Crypto API specification, it is possible to determine the key size for all standard key types).</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">*bits</span> <span class="pre">!=</span> <span class="pre">0</span></code>, the driver must check the value of <code class="docutils literal notranslate"><span class="pre">*bits</span></code> against the data and return <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_INVALID_ARGUMENT</span></code> if it does not match.
If the driver entry point changes <code class="docutils literal notranslate"><span class="pre">*bits</span></code> to a different value but returns <code class="docutils literal notranslate"><span class="pre">PSA_SUCCESS</span></code>, the core will consider the key as invalid and the import will fail.</p></li>
</ul>
</section>
<section id="key-validation">
<span id="id13"></span><h3><span class="section-number">4.6.2 </span>Key validation<a class="headerlink" href="#key-validation" title="Link to this heading">¶</a></h3>
<p>Key creation entry points must produce valid key data.
Key data is <em>valid</em> if operations involving the key are guaranteed to work functionally and not to cause indirect security loss.
Operation functions are supposed to receive valid keys, and should not have to check and report invalid keys.
For example:</p>
<ul class="simple">
<li><p>If a cryptographic mechanism is defined as having keying material of a certain size, or if the keying material involves integers that have to be in a certain range, key creation must ensure that the keying material has an appropriate size and falls within an appropriate range.</p></li>
<li><p>If a cryptographic operation involves a division by an integer which is provided as part of a key, key creation must ensure that this integer is nonzero.</p></li>
<li><p>If a cryptographic operation involves two keys A and B (or more), then the creation of A must ensure that using it does not risk compromising B.
This applies even if A’s policy does not explicitly allow a problematic operation, but A is exportable.
In particular, public keys that can potentially be used for key agreement are considered invalid and must not be created if they risk compromising the private key.</p></li>
<li><p>On the other hand, it is acceptable for import to accept a key that cannot be verified as valid if using this key would at most compromise the key itself and material that is secured with this key.
For example, RSA key import does not need to verify that the primes are actually prime.
Key import may accept an insecure key if the consequences of the insecurity are no worse than a leak of the key prior to its import.</p></li>
</ul>
<p>With opaque drivers, the key context can only be used by code from the same driver, so key validity is primarily intended to report key creation errors at creation time rather than during an operation.
With transparent drivers, the key context can potentially be used by code from a different provider, so key validity is critical for interoperability.</p>
<p>This section describes some minimal validity requirements for standard key types.</p>
<ul class="simple">
<li><p>For symmetric key types, check that the key size is suitable for the type.</p></li>
<li><p>For DES (<code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_DES</span></code>), additionally verify the parity bits.</p></li>
<li><p>For RSA (<code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_RSA_PUBLIC_KEY</span></code>, <code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_RSA_KEY_PAIR</span></code>), check the syntax of the key and make sanity checks on its components.
TODO: what sanity checks? Value ranges (e.g. p &lt; n), sanity checks such as parity, minimum and maximum size, what else?</p></li>
<li><p>For elliptic curve private keys (<code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_ECC_KEY_PAIR</span></code>), check the size and range.
TODO: what else?</p></li>
<li><p>For elliptic curve public keys (<code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_ECC_PUBLIC_KEY</span></code>), check the size and range, and that the point is on the curve.
TODO: what else?</p></li>
</ul>
</section>
</section>
<section id="entropy-collection-entry-point">
<span id="id14"></span><h2><span class="section-number">4.7 </span>Entropy collection entry point<a class="headerlink" href="#entropy-collection-entry-point" title="Link to this heading">¶</a></h2>
<p>A driver can declare an entropy source by providing a <code class="docutils literal notranslate"><span class="pre">&quot;get_entropy&quot;</span></code> entry point.
This entry point has the following prototype for a driver with the prefix <code class="docutils literal notranslate"><span class="pre">&quot;acme&quot;</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef uint32_t psa_driver_get_entropy_flags_t;

psa_status_t acme_get_entropy(psa_driver_get_entropy_flags_t flags,
                              size_t *estimate_bits,
                              uint8_t *output,
                              size_t output_size);
</pre></div>
</div>
<p>The semantics of the parameters is as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">flags</span></code>: a bit-mask of <a class="reference internal" href="#entropy-collection-flags"><span class="std std-ref">entropy collection flags</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">estimate_bits</span></code>: on success, an estimate of the amount of entropy that is present in the <code class="docutils literal notranslate"><span class="pre">output</span></code> buffer, in bits.
This must be at least <code class="docutils literal notranslate"><span class="pre">1</span></code> on success.
The value is ignored on failure.
Drivers should return a conservative estimate, even in circumstances where the quality of the entropy source is degraded due to environmental conditions (e.g. undervolting, low temperature, etc.).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code>: on success, this buffer contains non-deterministic data with an estimated entropy of at least <code class="docutils literal notranslate"><span class="pre">*estimate_bits</span></code> bits.
When the entropy is coming from a hardware peripheral, this should preferably be raw or lightly conditioned measurements from a physical process, such that statistical tests run over a sufficiently large amount of output can confirm the entropy estimates.
But this specification also permits entropy sources that are fully conditioned, for example when the Crypto API implementation is running within an application in an operating system and <code class="docutils literal notranslate"><span class="pre">&quot;get_entropy&quot;</span></code> returns data from the random generator in the operating system’s kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output_size</span></code>: the size of the <code class="docutils literal notranslate"><span class="pre">output</span></code> buffer in bytes.
This size should be large enough to allow a driver to pass unconditioned data with a low density of entropy; for example a peripheral that returns eight bytes of data with an estimated one bit of entropy cannot provide meaningful output in less than 8 bytes.</p></li>
</ul>
<p>Note that there is no output parameter indicating how many bytes the driver wrote to the buffer.
Such an output length indication is not necessary because the entropy may be located anywhere in the buffer, so the driver may write less than <code class="docutils literal notranslate"><span class="pre">output_size</span></code> bytes but the core does not need to know this.
The output parameter <code class="docutils literal notranslate"><span class="pre">estimate_bits</span></code> contains the amount of entropy, expressed in bits, which may be significantly less than <code class="docutils literal notranslate"><span class="pre">output_size</span> <span class="pre">*</span> <span class="pre">8</span></code>.</p>
<p>The entry point may return the following statuses:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_SUCCESS</span></code>: success.
The output buffer contains some entropy.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_ERROR_INSUFFICIENT_ENTROPY</span></code>: no entropy is available without blocking.
This is only permitted if the <code class="docutils literal notranslate"><span class="pre">PSA_DRIVER_GET_ENTROPY_NONBLOCK</span></code> flag is set.
The core may call <code class="docutils literal notranslate"><span class="pre">get_entropy</span></code> again later, giving time for entropy to be gathered or for adverse environmental conditions to be rectified.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_ERROR_NOT_SUPPORTED</span></code>: a flag is not recognized.
The core may try again with different flags.</p></li>
<li><p>Other error codes indicate a transient or permanent failure of the entropy source.</p></li>
</ul>
<p>Unlike most other entry points, if multiple transparent drivers include a <code class="docutils literal notranslate"><span class="pre">&quot;get_entropy&quot;</span></code> point, the core will call all of them (as well as the entry points from opaque drivers).
Fallback is not applicable to <code class="docutils literal notranslate"><span class="pre">&quot;get_entropy&quot;</span></code>.</p>
<section id="entropy-collection-flags">
<span id="id15"></span><h3><span class="section-number">4.7.1 </span>Entropy collection flags<a class="headerlink" href="#entropy-collection-flags" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_DRIVER_GET_ENTROPY_NONBLOCK</span></code>: If this flag is clean, the driver should block until it has at least one bit of entropy.
If this flag is set, the driver should avoid blocking if no entropy is readily available.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_DRIVER_GET_ENTROPY_KEEPALIVE</span></code>: This flag is intended to help with energy management for entropy-generating peripherals.
If this flag is set, the driver should expect another call to <code class="docutils literal notranslate"><span class="pre">acme_get_entropy</span></code> after a short time.
If this flag is clear, the core is not expecting to call the <code class="docutils literal notranslate"><span class="pre">&quot;get_entropy&quot;</span></code> entry point again within a short amount of time (but it may do so nonetheless).</p></li>
</ul>
<p>A very simple core can just pass <code class="docutils literal notranslate"><span class="pre">flags=0</span></code>.
All entropy drivers should support this case.</p>
<p>If the entry point returns <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_NOT_SUPPORTED</span></code>, the core may try calling the entry point again with fewer flags.
Drivers should be consistent from one call to the next with respect to which flags they support.
The core may cache an acceptable flag mask on its first call to an entry point.</p>
</section>
<section id="entropy-collection-and-blocking">
<h3><span class="section-number">4.7.2 </span>Entropy collection and blocking<a class="headerlink" href="#entropy-collection-and-blocking" title="Link to this heading">¶</a></h3>
<p>The intent of the <code class="docutils literal notranslate"><span class="pre">NONBLOCK</span></code> and <code class="docutils literal notranslate"><span class="pre">KEEPALIVE</span></code> <a class="reference internal" href="#entropy-collection-flags"><span class="std std-ref">flags</span></a> is to support drivers for TRNG (True Random Number Generator, i.e. an entropy source peripheral) that have a long ramp-up time, especially on platforms with multiple entropy sources.</p>
<p>Here is a suggested call sequence for entropy collection that leverages these flags:</p>
<ol class="arabic simple">
<li><p>The core makes a first round of calls to <code class="docutils literal notranslate"><span class="pre">&quot;get_entropy&quot;</span></code> on every source with the <code class="docutils literal notranslate"><span class="pre">NONBLOCK</span></code> flag set and the <code class="docutils literal notranslate"><span class="pre">KEEPALIVE</span></code> flag set, so that drivers can prepare the TRNG peripheral.</p></li>
<li><p>The core makes a second round of calls with the <code class="docutils literal notranslate"><span class="pre">NONBLOCK</span></code> flag clear and the <code class="docutils literal notranslate"><span class="pre">KEEPALIVE</span></code> flag clear to gather needed entropy.</p></li>
<li><p>If the second round does not collect enough entropy, the core makes more similar rounds, until the total amount of collected entropy is sufficient.</p></li>
</ol>
</section>
</section>
<section id="miscellaneous-driver-entry-points">
<h2><span class="section-number">4.8 </span>Miscellaneous driver entry points<a class="headerlink" href="#miscellaneous-driver-entry-points" title="Link to this heading">¶</a></h2>
<section id="driver-initialization">
<span id="id16"></span><h3><span class="section-number">4.8.1 </span>Driver initialization<a class="headerlink" href="#driver-initialization" title="Link to this heading">¶</a></h3>
<p>A driver may declare an <code class="docutils literal notranslate"><span class="pre">&quot;init&quot;</span></code> entry point in a capability with no algorithm, key type or key size.
If so, the core calls this entry point once during the initialization of the Crypto API implementation.
If the init entry point of any driver fails, the initialization of the Crypto API implementation fails.</p>
<p>When multiple drivers have an init entry point, the order in which they are called is unspecified.
It is also unspecified whether other drivers’ <code class="docutils literal notranslate"><span class="pre">&quot;init&quot;</span></code> entry points are called if one or more init entry point fails.</p>
<p>On platforms where the Crypto API implementation is a subsystem of a single application, the initialization of the Crypto API implementation takes place during the call to <code class="docutils literal notranslate"><span class="pre">psa_crypto_init()</span></code>.
On platforms where the Crypto API implementation is separate from the application or applications, the initialization of the Crypto API implementation takes place before or during the first time an application calls <code class="docutils literal notranslate"><span class="pre">psa_crypto_init()</span></code>.</p>
<p>The init entry point does not take any parameter.</p>
</section>
</section>
<section id="combining-multiple-drivers">
<h2><span class="section-number">4.9 </span>Combining multiple drivers<a class="headerlink" href="#combining-multiple-drivers" title="Link to this heading">¶</a></h2>
<p>To declare a cryptoprocessor can handle both cleartext and wrapped keys, you need to provide two driver descriptions, one for a transparent driver and one for an opaque driver.
You can use the mapping in capabilities’ <code class="docutils literal notranslate"><span class="pre">&quot;names&quot;</span></code> property to arrange for multiple driver entry points to map to the same C function.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169; 2020-2025 Arm Limited and/or its affiliates.
      
    </div>

    

    
  </body>
</html>