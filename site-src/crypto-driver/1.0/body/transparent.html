---
---

<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="5 Transparent drivers" />
<meta property="og:type" content="website" />
<meta property="og:url" content="{{ page.url | absolute_url }}" />
<link rel="canonical" href="{{ page.url | absolute_url }}" />
<meta property="og:site_name" content="PSA Certified Crypto Driver Interface 1.0" />
<meta property="og:description" content="Alpha Key format for transparent drivers: The format of a key for transparent drivers is the same as in applications. Refer to the documentation in the Key format sub-section of each key type in §9..." />
<meta name="description" content="Alpha Key format for transparent drivers: The format of a key for transparent drivers is the same as in applications. Refer to the documentation in the Key format sub-section of each key type in §9..." />

    <title>5 Transparent drivers &#8212; PSA Certified Crypto Driver Interface 1.0</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=f6a572b4" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
    <link rel="preconnect" type="text/css" href="https://fonts.googleapis.com" />
    <link rel="preconnect" type="text/css" href="https://fonts.gstatic.com" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;1,300;1,400&display=swap" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Noto+Sans+Mono:ital,wght@0,300;0,400;1,300&display=swap" />
    <script src="../_static/documentation_options.js?v=d052748e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6 Opaque drivers" href="opaque.html" />
    <link rel="prev" title="4 Driver entry points" href="entry-points.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/ARM_LOGO-2025_INK_RGB.svg" alt="Logo of PSA Certified Crypto Driver Interface"/>
            </a></p><hr />
<h3><a href="../index.html">PSA Certified<br />Crypto Driver Interface</a></h3>
111106<br/>
Non-confidential<br/>
Version 1.0 Alpha (Issue 1)
<hr />
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about/about.html">About this document</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1 Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">2 Overview of drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="manifest.html">3 Driver description</a></li>
<li class="toctree-l1"><a class="reference internal" href="entry-points.html">4 Driver entry points</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5 Transparent drivers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#key-format-for-transparent-drivers">5.1 Key format for transparent drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#key-management-with-transparent-drivers">5.2 Key management with transparent drivers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#key-import-with-transparent-drivers">5.2.1 Key import with transparent drivers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#random-generation-entry-points">5.3 Random generation entry points</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#random-generator-initialization">5.3.1 Random generator initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#entropy-injection">5.3.2 Entropy injection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#combining-entropy-sources-with-a-random-generation-driver">5.3.3 Combining entropy sources with a random generation driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#random-generator-drivers-without-entropy-injection">5.3.4 Random generator drivers without entropy injection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-get-random-entry-point">5.3.5 The <code class="docutils literal notranslate"><span class="pre">&quot;get_random&quot;</span></code> entry point</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fallback">5.4 Fallback</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="opaque.html">6 Opaque drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-drivers.html">7 Using drivers from an application</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix/open-issues.html">A Open questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/history.html">B Changes to the API</a></li>
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="watermark docutils container">
<p>Alpha</p>
</div>
<section id="transparent-drivers">
<h1><span class="section-number">5 </span>Transparent drivers<a class="headerlink" href="#transparent-drivers" title="Link to this heading">¶</a></h1>
<section id="key-format-for-transparent-drivers">
<span id="id1"></span><h2><span class="section-number">5.1 </span>Key format for transparent drivers<a class="headerlink" href="#key-format-for-transparent-drivers" title="Link to this heading">¶</a></h2>
<p>The format of a key for transparent drivers is the same as in applications.
Refer to the documentation in the <em>Key format</em> sub-section of each key type in <a class="reference external" href="https://arm-software.github.io/psa-api/crypto/1.3/api/keys/types.html#key-types">§9.2 Key types</a> in the Crypto API specification.
For custom key types defined by an implementation, refer to the documentation of that implementation.</p>
</section>
<section id="key-management-with-transparent-drivers">
<span id="id2"></span><h2><span class="section-number">5.2 </span>Key management with transparent drivers<a class="headerlink" href="#key-management-with-transparent-drivers" title="Link to this heading">¶</a></h2>
<p>Transparent drivers may provide the following key management entry points:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#key-import-with-transparent-drivers"><span class="std std-ref">&quot;import_key&quot;</span></a>: called by <code class="docutils literal notranslate"><span class="pre">psa_import_key()</span></code>, only when importing a key pair or a public key (key such that <code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_IS_ASYMMETRIC</span></code> is true).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;generate_key&quot;</span></code>: called by <code class="docutils literal notranslate"><span class="pre">psa_generate_key()</span></code>, only when generating a key pair (key such that <code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_IS_KEY_PAIR</span></code> is true).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;key_derivation_output_key&quot;</span></code>: called by <code class="docutils literal notranslate"><span class="pre">psa_key_derivation_output_key()</span></code>, only when deriving a key pair (key such that <code class="docutils literal notranslate"><span class="pre">PSA_KEY_TYPE_IS_KEY_PAIR</span></code> is true).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;export_public_key&quot;</span></code>: called by the core to obtain the public key of a key pair.
The core may call this function at any time to obtain the public key, which can be for <code class="docutils literal notranslate"><span class="pre">psa_export_public_key()</span></code> but also at other times, including during a cryptographic operation that requires the public key such as a call to <code class="docutils literal notranslate"><span class="pre">psa_verify_message()</span></code> on a key pair object.</p></li>
</ul>
<p>Transparent drivers are not involved when exporting, copying or destroying keys, or when importing, generating or deriving symmetric keys.</p>
<section id="key-import-with-transparent-drivers">
<span id="id3"></span><h3><span class="section-number">5.2.1 </span>Key import with transparent drivers<a class="headerlink" href="#key-import-with-transparent-drivers" title="Link to this heading">¶</a></h3>
<p>As discussed in <a class="reference internal" href="entry-points.html#driver-entry-points-for-key-management"><span class="std std-ref">the general section about key management entry points</span></a>, the key import entry points has the following prototype for a driver with the prefix <code class="docutils literal notranslate"><span class="pre">&quot;acme&quot;</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_import_key(const psa_key_attributes_t *attributes,
                             const uint8_t *data,
                             size_t data_length,
                             uint8_t *key_buffer,
                             size_t key_buffer_size,
                             size_t *key_buffer_length,
                             size_t *bits);
</pre></div>
</div>
<p>This entry point has several roles:</p>
<ol class="arabic simple">
<li><p>Parse the key data in the input buffer <code class="docutils literal notranslate"><span class="pre">data</span></code>.
The driver must support the export format for the key types that the entry point is declared for.
It may support additional formats as specified in the description of <a class="reference external" href="https://arm-software.github.io/psa-api/crypto/1.3/api/keys/management.html#c.psa_import_key">psa_import_key()</a> in the Crypto API specification.</p></li>
<li><p>Validate the key data.
The necessary validation is described in <a class="reference internal" href="entry-points.html#key-validation"><span class="secref">Key validation</span></a>.</p></li>
<li><p><a class="reference internal" href="entry-points.html#key-size-determination-on-import"><span class="std std-ref">Determine the key size</span></a> and output it through <code class="docutils literal notranslate"><span class="pre">*bits</span></code>.</p></li>
<li><p>Copy the validated key data from <code class="docutils literal notranslate"><span class="pre">data</span></code> to <code class="docutils literal notranslate"><span class="pre">key_buffer</span></code>.
The output must be in the canonical format documented for the key type: see the <em>Key format</em> sub-section of the key type in <a class="reference external" href="https://arm-software.github.io/psa-api/crypto/1.3/api/keys/types.html#key-types">§9.2 Key types</a>, so if the input is not in this format, the entry point must convert it.</p></li>
</ol>
</section>
</section>
<section id="random-generation-entry-points">
<span id="id4"></span><h2><span class="section-number">5.3 </span>Random generation entry points<a class="headerlink" href="#random-generation-entry-points" title="Link to this heading">¶</a></h2>
<p>A transparent driver may provide an operation family that can be used as a cryptographic random number generator.
The random generation mechanism must obey the following requirements:</p>
<ul class="simple">
<li><p>The random output must be of cryptographic quality, with a uniform distribution.
Therefore, if the random generator includes an entropy source, this entropy source must be fed through a CSPRNG (cryptographically secure pseudo-random number generator).</p></li>
<li><p>Random generation is expected to be fast.
(If a device can provide entropy but is slow at generating random data, declare it as an <a class="reference internal" href="entry-points.html#entropy-collection-entry-point"><span class="std std-ref">entropy driver</span></a> instead.)</p></li>
<li><p>The random generator should be able to incorporate entropy provided by an outside source.
If it isn’t, the random generator can only be used if it’s the only entropy source on the platform.
(A random generator peripheral can be declared as an <a class="reference internal" href="entry-points.html#entropy-collection-entry-point"><span class="std std-ref">entropy source</span></a> instead of a random generator; this way the core will combine it with other entropy sources.)</p></li>
<li><p>The random generator may either be deterministic (in the sense that it always returns the same data when given the same entropy inputs) or non-deterministic (including its own entropy source).
In other words, this interface is suitable both for PRNG (pseudo-random number generator, also known as DRBG (deterministic random bit generator)) and for NRBG (non-deterministic random bit generator).</p></li>
</ul>
<p>If no driver implements the random generation entry point family, the core provides an unspecified random generation mechanism.</p>
<p>This operation family requires the following type, entry points and parameters (TODO: where exactly are the parameters in the JSON structure?):</p>
<ul class="simple">
<li><p>Type <code class="docutils literal notranslate"><span class="pre">&quot;random_context_t&quot;</span></code>: the type of a random generation context.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;init_random&quot;</span></code> (entry point, optional): if this function is present, <a class="reference internal" href="#random-generator-initialization"><span class="std std-ref">the core calls it once</span></a> after allocating a <code class="docutils literal notranslate"><span class="pre">&quot;random_context_t&quot;</span></code> object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> (entry point, optional): the core calls this function to <a class="reference internal" href="#entropy-injection"><span class="std std-ref">inject entropy</span></a>.
This entry point is optional if the driver is for a peripheral that includes an entropy source of its own, however <a class="reference internal" href="#random-generator-drivers-without-entropy-injection"><span class="std std-ref">random generator drivers without entropy injection</span></a> have limited portability since they can only be used on platforms with no other entropy source.
This entry point is mandatory if <code class="docutils literal notranslate"><span class="pre">&quot;initial_entropy_size&quot;</span></code> is nonzero.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;get_random&quot;</span></code> (entry point, mandatory): the core calls this function whenever it needs to <a class="reference internal" href="#the-get-random-entry-point"><span class="std std-ref">obtain random data</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;initial_entropy_size&quot;</span></code> (integer, mandatory): the minimum number of bytes of entropy that the core must supply before the driver can output random data.
This can be <code class="docutils literal notranslate"><span class="pre">0</span></code> if the driver is for a peripheral that includes an entropy source of its own.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;reseed_entropy_size&quot;</span></code> (integer, optional): the minimum number of bytes of entropy that the core should supply via <a class="reference internal" href="#entropy-injection"><span class="std std-ref">&quot;add_entropy&quot;</span></a> when the driver runs out of entropy.
This value is also a hint for the size to supply if the core makes additional calls to <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code>, for example to enforce prediction resistance.
If omitted, the core should pass an amount of entropy corresponding to the expected security strength of the device (for example, pass 32 bytes of entropy when reseeding to achieve a security strength of 256 bits).
If specified, the core should pass the larger of <code class="docutils literal notranslate"><span class="pre">&quot;reseed_entropy_size&quot;</span></code> and the amount corresponding to the security strength.</p></li>
</ul>
<p>Random generation is not parametrized by an algorithm.
The choice of algorithm is up to the driver.</p>
<section id="random-generator-initialization">
<span id="id5"></span><h3><span class="section-number">5.3.1 </span>Random generator initialization<a class="headerlink" href="#random-generator-initialization" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;init_random&quot;</span></code> entry point has the following prototype for a driver with the prefix <code class="docutils literal notranslate"><span class="pre">&quot;acme&quot;</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_init_random(acme_random_context_t *context);
</pre></div>
</div>
<p>The core calls this entry point once after allocating a random generation context.
Initially, the context object is all-bits-zero.</p>
<p>If a driver does not have an <code class="docutils literal notranslate"><span class="pre">&quot;init_random&quot;</span></code> entry point, the context object passed to the first call to <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;get_random&quot;</span></code> will be all-bits-zero.</p>
</section>
<section id="entropy-injection">
<span id="id6"></span><h3><span class="section-number">5.3.2 </span>Entropy injection<a class="headerlink" href="#entropy-injection" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> entry point has the following prototype for a driver with the prefix <code class="docutils literal notranslate"><span class="pre">&quot;acme&quot;</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_add_entropy(acme_random_context_t *context,
                              const uint8_t *entropy,
                              size_t entropy_size);
</pre></div>
</div>
<p>The semantics of the parameters is as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">context</span></code>: a random generation context.
On the first call to <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code>, this object has been initialized by a call to the driver’s <code class="docutils literal notranslate"><span class="pre">&quot;init_random&quot;</span></code> entry point if one is present, and to all-bits-zero otherwise.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">entropy</span></code>: a buffer containing full-entropy data to seed the random generator.
“Full-entropy” means that the data is uniformly distributed and independent of any other observable quantity.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">entropy_size</span></code>: the size of the <code class="docutils literal notranslate"><span class="pre">entropy</span></code> buffer in bytes.
It is guaranteed to be at least <code class="docutils literal notranslate"><span class="pre">1</span></code>, but it may be smaller than the amount of entropy that the driver needs to deliver random data, in which case the core will call the <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> entry point again to supply more entropy.</p></li>
</ul>
<p>The core calls this function to supply entropy to the driver.
The driver must mix this entropy into its internal state.
The driver must mix the whole supplied entropy, even if there is more than what the driver requires, to ensure that all entropy sources are mixed into the random generator state.
The driver may mix additional entropy of its own.</p>
<p>The core may call this function at any time.
For example, to enforce prediction resistance, the core can call <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> immediately after each call to <code class="docutils literal notranslate"><span class="pre">&quot;get_random&quot;</span></code>.
The core must call this function in two circumstances:</p>
<ul class="simple">
<li><p>Before the first call to the <code class="docutils literal notranslate"><span class="pre">&quot;get_random&quot;</span></code> entry point, to supply <code class="docutils literal notranslate"><span class="pre">&quot;initial_entropy_size&quot;</span></code> bytes of entropy.</p></li>
<li><p>After a call to the <code class="docutils literal notranslate"><span class="pre">&quot;get_random&quot;</span></code> entry point returns less than the required amount of random data, to supply at least <code class="docutils literal notranslate"><span class="pre">&quot;reseed_entropy_size&quot;</span></code> bytes of entropy.</p></li>
</ul>
<p>When the driver requires entropy, the core can supply it with one or more successive calls to the <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> entry point.
If the required entropy size is zero, the core does not need to call <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code>.</p>
</section>
<section id="combining-entropy-sources-with-a-random-generation-driver">
<h3><span class="section-number">5.3.3 </span>Combining entropy sources with a random generation driver<a class="headerlink" href="#combining-entropy-sources-with-a-random-generation-driver" title="Link to this heading">¶</a></h3>
<p>This section provides guidance on combining one or more <a class="reference internal" href="entry-points.html#entropy-collection-entry-point"><span class="std std-ref">entropy sources</span></a> (each having a <code class="docutils literal notranslate"><span class="pre">&quot;get_entropy&quot;</span></code> entry point) with a random generation driver (with an <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> entry point).</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">&quot;get_entropy&quot;</span></code> returns data with an estimated amount of entropy that is in general less than the buffer size.
The core must apply a mixing algorithm to the output of <code class="docutils literal notranslate"><span class="pre">&quot;get_entropy&quot;</span></code> to obtain full-entropy data.</p>
<p>For example, the core may use a simple mixing scheme based on a pseudorandom function family (<em>F</em><sub>k</sub>) with an <em>E</em>-bit output where <em>E</em> = 8 entropy<sub>size</sub> and entropy<sub>size</sub> is the desired amount of entropy in bytes (typically the random driver’s <code class="docutils literal notranslate"><span class="pre">&quot;initial_entropy_size&quot;</span></code> property for the initial seeding and the <code class="docutils literal notranslate"><span class="pre">&quot;reseed_entropy_size&quot;</span></code> property for subsequent reseeding).
The core calls the <code class="docutils literal notranslate"><span class="pre">&quot;get_entropy&quot;</span></code> points of the available entropy drivers, outputting a string <em>s</em><sub>i</sub> and an entropy estimate <em>e</em><sub>i</sub> on the <em>i</em>th call.
It does so until the total entropy estimate <em>e</em><sub>1</sub> + <em>e</em><sub>2</sub> + … + <em>e</em><sub>n</sub> is at least <em>E</em>.
The core then calculates <em>F</em><sub>k</sub>(0) where <em>k</em> = <em>s</em><sub>1</sub> || <em>s</em><sub>2</sub> || … || <em>s</em><sub>n</sub>.
This value is a string of entropy<sub>size</sub>, and since (<em>F</em><sub>k</sub>) is a pseudorandom function family, <em>F</em><sub>k</sub>(0) is uniformly distributed over strings of entropy<sub>size</sub> bytes.
Therefore <em>F</em><sub>k</sub>(0) is a suitable value to pass to <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code>.</p>
<p>Note that the mechanism above is only given as an example.
Implementations may choose a different mechanism, for example involving multiple pools or intermediate compression functions.</p>
</section>
<section id="random-generator-drivers-without-entropy-injection">
<span id="id7"></span><h3><span class="section-number">5.3.4 </span>Random generator drivers without entropy injection<a class="headerlink" href="#random-generator-drivers-without-entropy-injection" title="Link to this heading">¶</a></h3>
<p>Random generator drivers should have the capability to inject additional entropy through the <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> entry point.
This ensures that the random generator depends on all the entropy sources that are available on the platform.
A driver where a call to <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> does not affect the state of the random generator is not compliant with this specification.</p>
<p>However, a driver may omit the <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> entry point.
This limits the driver’s portability: implementations of the Crypto API specification may reject drivers without an <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> entry point, or only accept such drivers in certain configurations.
In particular, the <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> entry point is required if:</p>
<ul class="simple">
<li><p>the implementation of the Crypto API includes an entropy source that is outside the driver; or</p></li>
<li><p>the core saves random data in persistent storage to be preserved across platform resets.</p></li>
</ul>
</section>
<section id="the-get-random-entry-point">
<span id="id8"></span><h3><span class="section-number">5.3.5 </span>The <code class="docutils literal notranslate"><span class="pre">&quot;get_random&quot;</span></code> entry point<a class="headerlink" href="#the-get-random-entry-point" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;get_random&quot;</span></code> entry point has the following prototype for a driver with the prefix <code class="docutils literal notranslate"><span class="pre">&quot;acme&quot;</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>psa_status_t acme_get_random(acme_random_context_t *context,
                             uint8_t *output,
                             size_t output_size,
                             size_t *output_length);
</pre></div>
</div>
<p>The semantics of the parameters is as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">context</span></code>: a random generation context.
If the driver’s <code class="docutils literal notranslate"><span class="pre">&quot;initial_entropy_size&quot;</span></code> property is nonzero, the core must have called <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> at least once with a total of at least <code class="docutils literal notranslate"><span class="pre">&quot;initial_entropy_size&quot;</span></code> bytes of entropy before it calls <code class="docutils literal notranslate"><span class="pre">&quot;get_random&quot;</span></code>.
Alternatively, if the driver’s <code class="docutils literal notranslate"><span class="pre">&quot;initial_entropy_size&quot;</span></code> property is zero and the core did not call <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code>, or if the driver has no <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> entry point, the core must have called <code class="docutils literal notranslate"><span class="pre">&quot;init_random&quot;</span></code> if present, and otherwise the context is all-bits zero.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code>: on success (including partial success), the first <code class="docutils literal notranslate"><span class="pre">*output_length</span></code> bytes of this buffer contain cryptographic-quality random data.
The output is not used on error.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output_size</span></code>: the size of the <code class="docutils literal notranslate"><span class="pre">output</span></code> buffer in bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">*output_length</span></code>: on success (including partial success), the number of bytes of random data that the driver has written to the <code class="docutils literal notranslate"><span class="pre">output</span></code> buffer.
This is preferably <code class="docutils literal notranslate"><span class="pre">output_size</span></code>, but the driver is allowed to return less data if it runs out of entropy as described below.
The core sets this value to 0 on entry.
The value is not used on error.</p></li>
</ul>
<p>The driver may return the following status codes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_SUCCESS</span></code>: the <code class="docutils literal notranslate"><span class="pre">output</span></code> buffer contains <code class="docutils literal notranslate"><span class="pre">*output_length</span></code> bytes of cryptographic-quality random data.
Note that this may be less than <code class="docutils literal notranslate"><span class="pre">output_size</span></code>; in this case the core should call the driver’s <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> method to supply at least <code class="docutils literal notranslate"><span class="pre">&quot;reseed_entropy_size&quot;</span></code> bytes of entropy before calling <code class="docutils literal notranslate"><span class="pre">&quot;get_random&quot;</span></code> again.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_ERROR_INSUFFICIENT_ENTROPY</span></code>: the core must supply additional entropy by calling the <code class="docutils literal notranslate"><span class="pre">&quot;add_entropy&quot;</span></code> entry point with at least <code class="docutils literal notranslate"><span class="pre">&quot;reseed_entropy_size&quot;</span></code> bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSA_ERROR_NOT_SUPPORTED</span></code>: the random generator is not available.
This is only permitted if the driver specification for random generation has the <a class="reference internal" href="#fallback"><span class="std std-ref">fallback property</span></a> enabled.</p></li>
<li><p>Other error codes such as <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_COMMUNICATION_FAILURE</span></code> or <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_HARDWARE_FAILURE</span></code> indicate a transient or permanent error.</p></li>
</ul>
</section>
</section>
<section id="fallback">
<span id="id9"></span><h2><span class="section-number">5.4 </span>Fallback<a class="headerlink" href="#fallback" title="Link to this heading">¶</a></h2>
<p>Sometimes cryptographic accelerators only support certain cryptographic mechanisms partially.
The capability description language allows specifying some restrictions, including restrictions on key sizes, but it cannot cover all the possibilities that may arise in practice.
Furthermore, it may be desirable to deploy the same binary image on different devices, only some of which have a cryptographic accelerators.
For these purposes, a transparent driver can declare that it only supports a <a class="reference internal" href="manifest.html#driver-description-capability"><span class="std std-ref">capability</span></a> partially, by setting the capability’s <code class="docutils literal notranslate"><span class="pre">&quot;fallback&quot;</span></code> property to true.</p>
<p>If a transparent driver entry point is part of a capability which has a true <code class="docutils literal notranslate"><span class="pre">&quot;fallback&quot;</span></code> property and returns <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_NOT_SUPPORTED</span></code>, the core will call the next transparent driver that supports the mechanism, if there is one.
The core considers drivers in the order given by the <a class="reference internal" href="overview.html#driver-description-list"><span class="std std-ref">driver description list</span></a>.</p>
<p>If all the available drivers have fallback enabled and return <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_NOT_SUPPORTED</span></code>, the core will perform the operation using built-in code.
As soon as a driver returns any value other than <code class="docutils literal notranslate"><span class="pre">PSA_ERROR_NOT_SUPPORTED</span></code> (<code class="docutils literal notranslate"><span class="pre">PSA_SUCCESS</span></code> or a different error code), this value is returned to the application, without attempting to call any other driver or built-in code.</p>
<p>If a transparent driver entry point is part of a capability where the <code class="docutils literal notranslate"><span class="pre">&quot;fallback&quot;</span></code> property is false or omitted, the core should not include any other code for this capability, whether built in or in another transparent driver.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169; 2020-2025 Arm Limited and/or its affiliates.
      
    </div>

    

    
  </body>
</html>